<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ChainRules</title><meta name="title" content="API · ChainRules"/><meta property="og:title" content="API · ChainRules"/><meta property="twitter:title" content="API · ChainRules"/><meta name="description" content="Documentation for ChainRules."/><meta property="og:description" content="Documentation for ChainRules."/><meta property="twitter:description" content="Documentation for ChainRules."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/indigo.css" rel="stylesheet" type="text/css"/><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="ChainRules logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ChainRules</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">How to use ChainRules as a rule author</span><ul><li><a class="tocitem" href="rule_author/intro.html">Introduction</a></li><li><a class="tocitem" href="rule_author/example.html">Pedagogical example</a></li><li><a class="tocitem" href="rule_author/tangents.html">Tangent types</a></li><li><a class="tocitem" href="rule_author/which_functions_need_rules.html">Which functions need rules?</a></li><li><a class="tocitem" href="rule_author/rule_definition_tools.html">Rule definition tools</a></li><li><a class="tocitem" href="rule_author/writing_good_rules.html">Writing good rules</a></li><li><a class="tocitem" href="rule_author/testing.html">Testing your rules</a></li><li><input class="collapse-toggle" id="menuitem-2-8" type="checkbox"/><label class="tocitem" for="menuitem-2-8"><span class="docs-label">Superpowers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="rule_author/superpowers/projectto.html"><code>ProjectTo</code></a></li><li><a class="tocitem" href="rule_author/superpowers/opt_out.html"><code>@opt_out</code></a></li><li><a class="tocitem" href="rule_author/superpowers/ruleconfig.html"><code>RuleConfig</code></a></li><li><a class="tocitem" href="rule_author/superpowers/gradient_accumulation.html">Gradient accumulation</a></li><li><a class="tocitem" href="rule_author/superpowers/mutation_support.html">Mutation Support (experimental)</a></li></ul></li><li><a class="tocitem" href="rule_author/converting_zygoterules.html">Converting ZygoteRules.@adjoint to rrules</a></li><li><a class="tocitem" href="rule_author/tips_for_packages.html">Tips for making your package work with AD</a></li><li><a class="tocitem" href="rule_author/debug_mode.html">Debug mode</a></li></ul></li><li><span class="tocitem">How to support ChainRules rules as an AD package author</span><ul><li><a class="tocitem" href="ad_author/use_in_ad_system.html">Usage in AD</a></li><li><a class="tocitem" href="ad_author/call_back_into_ad.html">Support calling back into ADs</a></li><li><a class="tocitem" href="ad_author/opt_out.html">Support opting out of rules</a></li></ul></li><li><span class="tocitem">The maths</span><ul><li><a class="tocitem" href="maths/propagators.html">The propagators: pushforward and pullback</a></li><li><a class="tocitem" href="maths/nondiff_points.html">Non-differentiable Points</a></li><li><a class="tocitem" href="maths/complex.html">Complex numbers</a></li><li><a class="tocitem" href="maths/arrays.html">Deriving array rules</a></li></ul></li><li><span class="tocitem">Design</span><ul><li><a class="tocitem" href="design/changing_the_primal.html">Changing the Primal</a></li><li><a class="tocitem" href="design/many_tangents.html">Many Tangent Types</a></li></ul></li><li><a class="tocitem" href="videos.html">Videos</a></li><li><a class="tocitem" href="FAQ.html">FAQ</a></li><li class="is-active"><a class="tocitem" href="api.html">API</a><ul class="internal"><li><a class="tocitem" href="#Rules"><span>Rules</span></a></li><li><a class="tocitem" href="#Rule-Definition-Tools"><span>Rule Definition Tools</span></a></li><li><a class="tocitem" href="#Tangent-Types"><span>Tangent Types</span></a></li><li><a class="tocitem" href="#Accumulation"><span>Accumulation</span></a></li><li><a class="tocitem" href="#RuleConfig"><span>RuleConfig</span></a></li><li><a class="tocitem" href="#ProjectTo"><span>ProjectTo</span></a></li><li><a class="tocitem" href="#Ignoring-gradients"><span>Ignoring gradients</span></a></li><li><a class="tocitem" href="#Internal"><span>Internal</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="api.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDiff/ChainRulesCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation"><a class="docs-heading-anchor" href="#API-Documentation">API Documentation</a><a id="API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documentation" title="Permalink"></a></h1><h2 id="Rules"><a class="docs-heading-anchor" href="#Rules">Rules</a><a id="Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rules" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}" href="#ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>ChainRulesCore.frule</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">frule([::RuleConfig,] (Δf, Δx...), f, x...)</code></pre><p>Expressing the output of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-julia hljs">(Ω, ΔΩ)</code></pre><p>The second return value is the tangent w.r.t. the output.</p><p>If no method matching <code>frule((Δf, Δx...), f, x...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-julia-repl hljs">julia&gt; dself = NoTangent();

julia&gt; x = rand()
0.8236475079774124

julia&gt; sinx, Δsinx = frule((dself, 1), sin, x)
(0.7336293678134624, 0.6795498147167869)

julia&gt; sinx == sin(x)
true

julia&gt; Δsinx == cos(x)
true</code></pre><p>Unary input, binary output scalar function:</p><pre><code class="language-julia-repl hljs">julia&gt; sincosx, Δsincosx = frule((dself, 1), sincos, x);

julia&gt; sincosx == sincos(x)
true

julia&gt; Δsincosx[1] == cos(x)
true

julia&gt; Δsincosx[2] == -sin(x)
true</code></pre><p>Note that techically speaking julia does not have multiple output functions, just functions that return a single output that is iterable, like a <code>Tuple</code>. So this is actually a <a href="api.html#ChainRulesCore.Tangent"><code>Tangent</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; Δsincosx
Tangent{Tuple{Float64, Float64}}(0.6795498147167869, -0.7336293678134624)</code></pre><p>The optional <a href="api.html#RuleConfig"><code>RuleConfig</code></a> option allows specifying frules only for AD systems that support given features. If not needed, then it can be omitted and the <code>frule</code> without it will be hit as a fallback. This is the case for most rules.</p><p>See also: <a href="api.html#ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}"><code>rrule</code></a>, <a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>@scalar_rule</code></a>, <a href="api.html#RuleConfig"><code>RuleConfig</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/rules.jl#L1-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}" href="#ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}"><code>ChainRulesCore.rrule</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rrule([::RuleConfig,] f, x...)</code></pre><p>Expressing <code>x</code> as the tuple <code>(x₁, x₂, ...)</code> and the output tuple of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-julia hljs">(Ω, (Ω̄₁, Ω̄₂, ...) -&gt; (s̄elf, x̄₁, x̄₂, ...))</code></pre><p>Where the second return value is the the propagation rule or pullback. It takes in cotangents corresponding to the outputs (<code>x̄₁, x̄₂, ...</code>), and <code>s̄elf</code>, the internal values of the function itself (for closures)</p><p>If no method matching <code>rrule(f, xs...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-julia-repl hljs">julia&gt; x = rand();

julia&gt; sinx, sin_pullback = rrule(sin, x);

julia&gt; sinx == sin(x)
true

julia&gt; sin_pullback(1) == (NoTangent(), cos(x))
true</code></pre><p>binary input, unary output scalar function:</p><pre><code class="language-julia-repl hljs">julia&gt; x, y = rand(2);

julia&gt; hypotxy, hypot_pullback = rrule(hypot, x, y);

julia&gt; hypotxy == hypot(x, y)
true

julia&gt; hypot_pullback(1) == (NoTangent(), (x / hypot(x, y)), (y / hypot(x, y)))
true</code></pre><p>The optional <a href="api.html#RuleConfig"><code>RuleConfig</code></a> option allows specifying rrules only for AD systems that support given features. If not needed, then it can be omitted and the <code>rrule</code> without it will be hit as a fallback. This is the case for most rules.</p><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>@scalar_rule</code></a>, <a href="api.html#RuleConfig"><code>RuleConfig</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/rules.jl#L83-L134">source</a></section></article><h2 id="Rule-Definition-Tools"><a class="docs-heading-anchor" href="#Rule-Definition-Tools">Rule Definition Tools</a><a id="Rule-Definition-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Definition-Tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.@non_differentiable-Tuple{Any}" href="#ChainRulesCore.@non_differentiable-Tuple{Any}"><code>ChainRulesCore.@non_differentiable</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@non_differentiable(signature_expression)</code></pre><p>A helper to make it easier to declare that a method is not differentiable. This is a short-hand for defining an <a href="api.html#ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>frule</code></a> and <a href="api.html#ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}"><code>rrule</code></a> that return <a href="api.html#ChainRulesCore.NoTangent"><code>NoTangent()</code></a> for all partials (even for the function <code>s̄elf</code>-partial itself)</p><p>Keyword arguments should not be included.</p><pre><code class="language-julia-repl hljs">julia&gt; @non_differentiable Base.:(==)(a, b)

julia&gt; _, pullback = rrule(==, 2.0, 3.0);

julia&gt; pullback(1.0)
(NoTangent(), NoTangent(), NoTangent())</code></pre><p>You can place type-constraints in the signature:</p><pre><code class="language-julia-repl hljs">julia&gt; @non_differentiable Base.length(xs::Union{Number, Array})

julia&gt; frule((ZeroTangent(), 1), length, [2.0, 3.0])
(2, NoTangent())</code></pre><div class="admonition is-warning" id="Warning-ef68131f311daf1d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-ef68131f311daf1d" title="Permalink"></a></header><div class="admonition-body"><p>This helper macro covers only the simple common cases. It does not support <code>where</code>-clauses. For these you can declare the <code>rrule</code> and <code>frule</code> directly</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/rule_definition_tools.jl#L345-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.@opt_out-Tuple{Any}" href="#ChainRulesCore.@opt_out-Tuple{Any}"><code>ChainRulesCore.@opt_out</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@opt_out frule([config], _, f, args...)
@opt_out rrule([config], f, args...)</code></pre><p>This allows you to opt-out of an <code>frule</code> or an <code>rrule</code> by providing a more specific method, that says to use the AD system to differentiate it.</p><p>For example, consider some function <code>foo(x::AbtractArray)</code>. In general, you know an efficient and generic way to implement its <code>rrule</code>. You do so, (likely making use of <a href="api.html#ProjectTo"><code>ProjectTo</code></a>). But it actually turns out that for some <code>FancyArray</code> type it is better to let the AD do its thing.</p><p>Then you would write something like:</p><pre><code class="language-julia hljs">function rrule(::typeof(foo), x::AbstractArray)
    foo_pullback(ȳ) = ...
    return foo(x), foo_pullback
end

@opt_out rrule(::typeof(foo), ::FancyArray)</code></pre><p>This will generate an <a href="api.html#ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}"><code>rrule</code></a> that returns <code>nothing</code>, and will also add a similar entry to <a href="api.html#ChainRulesCore.no_rrule"><code>ChainRulesCore.no_rrule</code></a>.</p><p>Similar applies for <a href="api.html#ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>frule</code></a> and <a href="api.html#ChainRulesCore.no_frule"><code>ChainRulesCore.no_frule</code></a></p><p>For more information see the <a href="rule_author/superpowers/opt_out.html#opt_out">documentation on opting out of rules</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/rule_definition_tools.jl#L480-L509">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.@scalar_rule-Tuple{Any, Any, Vararg{Any, N} where N}" href="#ChainRulesCore.@scalar_rule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>ChainRulesCore.@scalar_rule</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@scalar_rule(f(x₁, x₂, ...),
             @setup(statement₁, statement₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>A convenience macro that generates simple scalar forward or reverse rules using the provided partial derivatives. Specifically, generates the corresponding methods for <code>frule</code> and <code>rrule</code>:</p><pre><code class="language-julia hljs">function ChainRulesCore.frule((NoTangent(), Δx₁, Δx₂, ...), ::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, (
            (∂f₁_∂x₁ * Δx₁ + ∂f₁_∂x₂ * Δx₂ + ...),
            (∂f₂_∂x₁ * Δx₁ + ∂f₂_∂x₂ * Δx₂ + ...),
            ...
        )
end

function ChainRulesCore.rrule(::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, ((ΔΩ₁, ΔΩ₂, ...)) -&gt; (
            NoTangent(),
            ∂f₁_∂x₁ * ΔΩ₁ + ∂f₂_∂x₁ * ΔΩ₂ + ...),
            ∂f₁_∂x₂ * ΔΩ₁ + ∂f₂_∂x₂ * ΔΩ₂ + ...),
            ...
        )
end</code></pre><p>If no type constraints in <code>f(x₁, x₂, ...)</code> within the call to <code>@scalar_rule</code> are provided, each parameter in the resulting <code>frule</code>/<code>rrule</code> definition is given a type constraint of <code>Number</code>. Constraints may also be explicitly be provided to override the <code>Number</code> constraint, e.g. <code>f(x₁::Complex, x₂)</code>, which will constrain <code>x₁</code> to <code>Complex</code> and <code>x₂</code> to <code>Number</code>.</p><p>At present this does not support defining for closures/functors. Thus in reverse-mode, the first returned partial, representing the derivative with respect to the function itself, is always <code>NoTangent()</code>. And in forward-mode, the first input to the returned propagator is always ignored.</p><p>The result of <code>f(x₁, x₂, ...)</code> is automatically bound to <code>Ω</code>. This allows the primal result to be conveniently referenced (as <code>Ω</code>) within the derivative/setup expressions.</p><p>This macro assumes complex functions are holomorphic. In general, for non-holomorphic functions, the <code>frule</code> and <code>rrule</code> must be defined manually.</p><p>If the derivative is one, (e.g. for identity functions) <code>true</code> can be used as the most general multiplicative identity.</p><p>The <code>@setup</code> argument can be elided if no setup code is need. In other words:</p><pre><code class="language-julia hljs">@scalar_rule(f(x₁, x₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>is equivalent to:</p><pre><code class="language-julia hljs">@scalar_rule(f(x₁, x₂, ...),
             @setup(nothing),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>For examples, see ChainRules&#39; <code>rulesets</code> directory.</p><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}"><code>rrule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/rule_definition_tools.jl#L11-L90">source</a></section></article><h2 id="Tangent-Types"><a class="docs-heading-anchor" href="#Tangent-Types">Tangent Types</a><a id="Tangent-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Tangent-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.AbstractZero" href="#ChainRulesCore.AbstractZero"><code>ChainRulesCore.AbstractZero</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractZero &lt;: AbstractTangent</code></pre><p>Supertype for zero-like tangents—i.e., tangents that act like zero when added or multiplied to other values. If an AD system encounters a propagator that takes as input only subtypes of <code>AbstractZero</code>, then it can stop performing AD operations. All propagators are linear functions, and thus the final result will be zero.</p><p>All <code>AbstractZero</code> subtypes are singleton types. There are two of them: <a href="api.html#ChainRulesCore.ZeroTangent"><code>ZeroTangent()</code></a> and <a href="api.html#ChainRulesCore.NoTangent"><code>NoTangent()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/tangent_types/abstract_zero.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.NoTangent" href="#ChainRulesCore.NoTangent"><code>ChainRulesCore.NoTangent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoTangent() &lt;: AbstractZero</code></pre><p>This tangent indicates that the derivative does not exist. It is the tangent type for primal types that are not differentiable, such as integers or booleans (when they are not being used to represent floating-point values). The only valid way to perturb such values is to not change them at all. As a consequence, <code>NoTangent</code> is functionally identical to <code>ZeroTangent()</code>, but it provides additional semantic information.</p><p>Adding <code>NoTangent()</code> to a primal is generally wrong: gradient-based methods cannot be used to optimize over discrete variables. An optimization package making use of this might want to check for such a case.</p><div class="admonition is-info" id="Note-3cbbd213e7378702"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-3cbbd213e7378702" title="Permalink"></a></header><div class="admonition-body"><p>This does not indicate that the derivative is not implemented, but rather that mathematically it is not defined.</p></div></div><p>This mostly shows up as the derivative with respect to dimension, index, or size arguments.</p><pre><code class="language-julia hljs">function rrule(fill, x, len::Int)
    y = fill(x, len)
    fill_pullback(ȳ) = (NoTangent(), @thunk(sum(Ȳ)), NoTangent())
    return y, fill_pullback
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/tangent_types/abstract_zero.jl#L65-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.ZeroTangent" href="#ChainRulesCore.ZeroTangent"><code>ChainRulesCore.ZeroTangent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ZeroTangent() &lt;: AbstractZero</code></pre><p>The additive identity for tangents. This is basically the same as <code>0</code>. A derivative of <code>ZeroTangent()</code> does not propagate through the primal function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/tangent_types/abstract_zero.jl#L51-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.zero_tangent" href="#ChainRulesCore.zero_tangent"><code>ChainRulesCore.zero_tangent</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero_tangent(primal)</code></pre><p>This returns an appropriate zero tangent suitable for accumulating tangents of the primal. For mutable composites types this is a structural <a href="rule_author/superpowers/mutation_support.html#MutableTangent"><code>MutableTangent</code></a> For <code>Array</code>s, it is applied recursively for each element. For other types, in particular immutable types, we do not make promises beyond that it will be <code>iszero</code> and suitable for accumulating against. For types without a tangent space (e.g. singleton structs) this returns <code>NoTangent()</code>. In general, it is more likely to produce a structural tangent.</p><div class="admonition is-warning" id="Exprimental-2edba31eda02325c"><header class="admonition-header">Exprimental<a class="admonition-anchor" href="#Exprimental-2edba31eda02325c" title="Permalink"></a></header><div class="admonition-body"><p><code>zero_tangent</code>is an experimental feature, and is part of the mutation support featureset. While this notice remains it may have changes in behavour, and interface in any <em>minor</em> version of ChainRulesCore. Exactly how it should be used (e.g. is it forward-mode only?)</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/tangent_types/abstract_zero.jl#L98-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.MutableTangent" href="#ChainRulesCore.MutableTangent"><code>ChainRulesCore.MutableTangent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MutableTangent{P}(fields) &lt;: StructuralTangent{P} &lt;: AbstractTangent</code></pre><p>This type represents the tangent to a mutable struct. It itself is also mutable.</p><div class="admonition is-warning" id="Exprimental-1efc259b0c55dd28"><header class="admonition-header">Exprimental<a class="admonition-anchor" href="#Exprimental-1efc259b0c55dd28" title="Permalink"></a></header><div class="admonition-body"><p>MutableTangent is an experimental feature, and is part of the mutation support featureset. While this notice remains it may have changes in behavour, and interface in any <em>minor</em> version of ChainRulesCore. Exactly how it should be used (e.g. is it forward-mode only?)</p></div></div><div class="admonition is-warning" id="Do-not-directly-mess-with-the-tangent-backing-data-1b34e22ffe81f85d"><header class="admonition-header">Do not directly mess with the tangent backing data<a class="admonition-anchor" href="#Do-not-directly-mess-with-the-tangent-backing-data-1b34e22ffe81f85d" title="Permalink"></a></header><div class="admonition-body"><p>It is relatively straight forward for a forwards-mode AD to work correctly in the presence of mutation and aliasing of primal values. However, this requires that the tangent is aliased in turn and conversely that it is copied when the primal is). If you seperately alias the backing data, etc by using the internal <code>ChainRulesCore.backing</code> function you can break this.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/tangent_types/structural_tangent.jl#L57-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.StructuralTangent" href="#ChainRulesCore.StructuralTangent"><code>ChainRulesCore.StructuralTangent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StructuralTangent{P} &lt;: AbstractTangent</code></pre><p>Representing the type of the tangent of a <code>struct</code> <code>P</code> (or a <code>Tuple</code>/<code>NamedTuple</code>). as an object with mirroring fields.</p><div class="admonition is-warning" id="Exprimental-8dd4332a5a0c2834"><header class="admonition-header">Exprimental<a class="admonition-anchor" href="#Exprimental-8dd4332a5a0c2834" title="Permalink"></a></header><div class="admonition-body"><p><code>StructuralTangent</code> is an experimental feature, and is part of the mutation support featureset. The <code>StructuralTangent</code> constructor returns a <code>MutableTangent</code> for mutable structs. <code>MutableTangent</code> is an experimental feature. Thus use of <code>StructuralTangent</code> (rather than <code>Tangent</code> directly) is also experimental. While this notice remains it may have changes in behavour, and interface in any <em>minor</em> version of ChainRulesCore.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/tangent_types/structural_tangent.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.Tangent" href="#ChainRulesCore.Tangent"><code>ChainRulesCore.Tangent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tangent{P, T} &lt;: StructuralTangent{P} &lt;: AbstractTangent</code></pre><p>This type represents the tangent for a <code>struct</code>/<code>NamedTuple</code>, or <code>Tuple</code>. <code>P</code> is the the corresponding primal type that this is a tangent for.</p><p><code>Tangent{P}</code> should have fields (technically properties), that match to a subset of the fields of the primal type; and each should be a tangent type matching to the primal type of that field. Fields of the P that are not present in the Tangent are treated as <code>Zero</code>.</p><p><code>T</code> is an implementation detail representing the backing data structure. For Tuple it will be a Tuple, and for everything else it will be a <code>NamedTuple</code>. It should not be passed in by user.</p><p>For <code>Tangent</code>s of <code>Tuple</code>s, <code>iterate</code> and <code>getindex</code> are overloaded to behave similarly to for a tuple. For <code>Tangent</code>s of <code>struct</code>s, <code>getproperty</code> is overloaded to allow for accessing values via <code>tangent.fieldname</code>. Any fields not explictly present in the <code>Tangent</code> are treated as being set to <code>ZeroTangent()</code>. To make a <code>Tangent</code> have all the fields of the primal the <a href="api.html#ChainRulesCore.canonicalize-Union{Tuple{Tangent{P, var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:(NamedTuple{L, T} where T&lt;:Tuple)}, Tuple{L}, Tuple{P}} where {P, L}"><code>canonicalize</code></a> function is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/tangent_types/structural_tangent.jl#L16-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.canonicalize-Union{Tuple{Tangent{P, var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:(NamedTuple{L, T} where T&lt;:Tuple)}, Tuple{L}, Tuple{P}} where {P, L}" href="#ChainRulesCore.canonicalize-Union{Tuple{Tangent{P, var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:(NamedTuple{L, T} where T&lt;:Tuple)}, Tuple{L}, Tuple{P}} where {P, L}"><code>ChainRulesCore.canonicalize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">canonicalize(tangent::Tangent{P}) -&gt; Tangent{P}</code></pre><p>Return the canonical <code>Tangent</code> for the primal type <code>P</code>. The property names of the returned <code>Tangent</code> match the field names of the primal, and all fields of <code>P</code> not present in the input <code>tangent</code> are explictly set to <code>ZeroTangent()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/tangent_types/structural_tangent.jl#L427-L433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.InplaceableThunk" href="#ChainRulesCore.InplaceableThunk"><code>ChainRulesCore.InplaceableThunk</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InplaceableThunk(add!::Function, val::Thunk)</code></pre><p>A wrapper for a <code>Thunk</code>, that allows it to define an inplace <code>add!</code> function.</p><p><code>add!</code> should be defined such that: <code>ithunk.add!(Δ) = Δ .+= ithunk.val</code> but it should do this more efficently than simply doing this directly. (Otherwise one can just use a normal <code>Thunk</code>).</p><p>Most operations on an <code>InplaceableThunk</code> treat it just like a normal <code>Thunk</code>; and destroy its inplacability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/tangent_types/thunks.jl#L229-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.Thunk" href="#ChainRulesCore.Thunk"><code>ChainRulesCore.Thunk</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Thunk(()-&gt;v)</code></pre><p>A thunk is a deferred computation. It wraps a zero argument closure that when invoked returns a tangent. <code>@thunk(v)</code> is a macro that expands into <code>Thunk(()-&gt;v)</code>.</p><p>To evaluate the wrapped closure, call <a href="api.html#ChainRulesCore.unthunk-Tuple{Any}"><code>unthunk</code></a> which is a no-op when the argument is not a <code>Thunk</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; t = @thunk(3)
Thunk(var&quot;#4#5&quot;())

julia&gt; unthunk(t)
3</code></pre><p><strong>When to <code>@thunk</code>?</strong></p><p>When writing <code>rrule</code>s (and to a lesser exent <code>frule</code>s), it is important to <code>@thunk</code> appropriately. Propagation rules that return multiple derivatives may not have all deriviatives used.  By <code>@thunk</code>ing the work required for each derivative, they then compute only what is needed.</p><p><strong>How do thunks prevent work?</strong></p><p>If we have <code>res = pullback(...) = @thunk(f(x)), @thunk(g(x))</code> then if we did <code>dx + res[1]</code> then only <code>f(x)</code> would be evaluated, not <code>g(x)</code>. Also if we did <code>ZeroTangent() * res[1]</code> then the result would be <code>ZeroTangent()</code> and <code>f(x)</code> would not be evaluated.</p><p><strong>So why not thunk everything?</strong></p><p><code>@thunk</code> creates a closure over the expression, which (effectively) creates a <code>struct</code> with a field for each variable used in the expression, and call overloaded.</p><p>Do not use <code>@thunk</code> if this would be equal or more work than actually evaluating the expression itself. This is commonly the case for scalar operators.</p><p>For more details see the manual section <a href="https://juliadiff.org/ChainRulesCore.jl/dev/rule_author/writing_good_rules.html#Use-Thunks-appropriately">on using thunks effectively</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/tangent_types/thunks.jl#L171-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.unthunk-Tuple{Any}" href="#ChainRulesCore.unthunk-Tuple{Any}"><code>ChainRulesCore.unthunk</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unthunk(x)</code></pre><p>On <code>AbstractThunk</code>s this removes 1 layer of thunking. On any other type, it is the identity operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/tangent_types/thunks.jl#L155-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.@thunk-Tuple{Any}" href="#ChainRulesCore.@thunk-Tuple{Any}"><code>ChainRulesCore.@thunk</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@thunk expr</code></pre><p>Define a <a href="api.html#ChainRulesCore.Thunk"><code>Thunk</code></a> wrapping the <code>expr</code>, to lazily defer its evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/tangent_types/thunks.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.@not_implemented-Tuple{Any}" href="#ChainRulesCore.@not_implemented-Tuple{Any}"><code>ChainRulesCore.@not_implemented</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@not_implemented(info)</code></pre><p>Create a tangent that indicates that the derivative is not implemented.</p><p>The <code>info</code> should be useful information about the missing tangent for debugging.</p><div class="admonition is-info" id="Note-631abda396a46c91"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-631abda396a46c91" title="Permalink"></a></header><div class="admonition-body"><p>This macro should be used only if the automatic differentiation would error otherwise. It is mostly useful if the function has multiple inputs or outputs, and one has worked out analytically and implemented some but not all tangents.</p></div></div><div class="admonition is-info" id="Note-6f38fe77311b93dc"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-6f38fe77311b93dc" title="Permalink"></a></header><div class="admonition-body"><p>It is good practice to include a link to a GitHub issue about the missing tangent in the debugging information.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/tangent_types/notimplemented.jl#L1-L16">source</a></section></article><h2 id="Accumulation"><a class="docs-heading-anchor" href="#Accumulation">Accumulation</a><a id="Accumulation-1"></a><a class="docs-heading-anchor-permalink" href="#Accumulation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.add!!" href="#ChainRulesCore.add!!"><code>ChainRulesCore.add!!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add!!(x, y)</code></pre><p>Returns <code>x+y</code>, potentially mutating <code>x</code> in-place to hold this value. This avoids allocations when <code>x</code> can be mutated in this way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/accumulation.jl#L1-L6">source</a></section><section><div><pre><code class="language-julia hljs">add!!(x, t::InplacableThunk)</code></pre><p>The specialization of <code>add!!</code> for <a href="api.html#ChainRulesCore.InplaceableThunk"><code>InplaceableThunk</code></a> promises to only call <code>t.add!</code> on <code>x</code> if <code>x</code> is suitably mutable; otherwise it will be out of place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/accumulation.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.is_inplaceable_destination" href="#ChainRulesCore.is_inplaceable_destination"><code>ChainRulesCore.is_inplaceable_destination</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_inplaceable_destination(x) -&gt; Bool</code></pre><p>Returns true if <code>x</code> is suitable for for storing inplace accumulation of gradients. For arrays this means <code>x .= y</code> will mutate <code>x</code>, if <code>y</code> is an appropriate tangent.</p><p>Here &quot;appropriate&quot; means that <code>y</code> cannot be complex unless <code>x</code> is too, and that for structured matrices like <code>x isa Diagonal</code>, <code>y</code> shares this structure.</p><div class="admonition is-info" id="history-43181d59339da0f6"><header class="admonition-header">history<a class="admonition-anchor" href="#history-43181d59339da0f6" title="Permalink"></a></header><div class="admonition-body"><p>Wrapper array types should overload this function if they can be written into. Before ChainRulesCore 1.16, it would guess <code>true</code> for most wrappers based on <code>parent</code>, but this is not safe, e.g. it will lead to an error with ReadOnlyArrays.jl. </p></div></div><p>There must always be a correct non-mutating path, so in uncertain cases, this function returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/accumulation.jl#L37-L53">source</a></section></article><h2 id="RuleConfig"><a class="docs-heading-anchor" href="#RuleConfig">RuleConfig</a><a id="RuleConfig-1"></a><a class="docs-heading-anchor-permalink" href="#RuleConfig" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.HasForwardsMode" href="#ChainRulesCore.HasForwardsMode"><code>ChainRulesCore.HasForwardsMode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HasForwardsMode &lt;: ForwardsModeCapability</code></pre><p>This trait indicates that a <code>RuleConfig{&gt;:HasForwardsMode}</code> can perform forward mode AD. If it is set then <a href="api.html#ChainRulesCore.frule_via_ad"><code>frule_via_ad</code></a> must be implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/config.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.HasReverseMode" href="#ChainRulesCore.HasReverseMode"><code>ChainRulesCore.HasReverseMode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HasReverseMode &lt;: ReverseModeCapability</code></pre><p>This trait indicates that a <code>RuleConfig{&gt;:HasReverseMode}</code> can perform reverse mode AD. If it is set then <a href="api.html#ChainRulesCore.rrule_via_ad"><code>rrule_via_ad</code></a> must be implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/config.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.NoForwardsMode" href="#ChainRulesCore.NoForwardsMode"><code>ChainRulesCore.NoForwardsMode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoForwardsMode &lt;: ForwardsModeCapability</code></pre><p>This is the complement to <a href="api.html#ChainRulesCore.HasForwardsMode"><code>HasForwardsMode</code></a>. To avoid ambiguities [<code>RuleConfig</code>]s that do not support performing forwards mode AD should be <code>RuleConfig{&gt;:NoForwardsMode}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/config.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.NoReverseMode" href="#ChainRulesCore.NoReverseMode"><code>ChainRulesCore.NoReverseMode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoReverseMode &lt;: ReverseModeCapability</code></pre><p>This is the complement to <a href="api.html#ChainRulesCore.HasReverseMode"><code>HasReverseMode</code></a>. To avoid ambiguities [<code>RuleConfig</code>]s that do not support performing reverse mode AD should be <code>RuleConfig{&gt;:NoReverseMode}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/config.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.RuleConfig" href="#ChainRulesCore.RuleConfig"><code>ChainRulesCore.RuleConfig</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RuleConfig{T}</code></pre><p>The configuration for what rules to use. <code>T</code>: <strong>traits</strong>. This should be a <code>Union</code> of all special traits needed for rules to be allowed to be defined for your AD. If nothing special this should be set to <code>Union{}</code>.</p><p><strong>AD authors</strong> should define a subtype of <code>RuleConfig</code> to use when calling <code>frule</code>/<code>rrule</code>.</p><p><strong>Rule authors</strong> can dispatch on this config when defining rules. For example:</p><pre><code class="language-julia hljs"># only define rrule for `pop!` on AD systems where mutation is supported.
rrule(::RuleConfig{&gt;:SupportsMutation}, typeof(pop!), ::Vector) = ...

# this definition of map is for any AD that defines a forwards mode
rrule(conf::RuleConfig{&gt;:HasForwardsMode}, typeof(map), ::Vector) = ...

# this definition of map is for any AD that only defines a reverse mode.
# It is not as good as the rrule that can be used if the AD defines a forward-mode as well.
rrule(conf::RuleConfig{&gt;:Union{NoForwardsMode, HasReverseMode}}, typeof(map), ::Vector) = ...</code></pre><p>For more details see <a href="rule_author/superpowers/ruleconfig.html#config">rule configurations and calling back into AD</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/config.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.frule_via_ad" href="#ChainRulesCore.frule_via_ad"><code>ChainRulesCore.frule_via_ad</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">frule_via_ad(::RuleConfig{&gt;:HasForwardsMode}, ȧrgs, f, args...; kwargs...)</code></pre><p>This function has the same API as <a href="api.html#ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>frule</code></a>, but operates via performing forwards mode automatic differentiation. Any <code>RuleConfig</code> subtype that supports the <a href="api.html#ChainRulesCore.HasForwardsMode"><code>HasForwardsMode</code></a> special feature must provide an implementation of it.</p><p>See also: <a href="api.html#ChainRulesCore.rrule_via_ad"><code>rrule_via_ad</code></a>, <a href="api.html#RuleConfig"><code>RuleConfig</code></a> and the documentation on <a href="rule_author/superpowers/ruleconfig.html#config">rule configurations and calling back into AD</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/config.jl#L67-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.rrule_via_ad" href="#ChainRulesCore.rrule_via_ad"><code>ChainRulesCore.rrule_via_ad</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rrule_via_ad(::RuleConfig{&gt;:HasReverseMode}, f, args...; kwargs...)</code></pre><p>This function has the same API as <a href="api.html#ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}"><code>rrule</code></a>, but operates via performing reverse mode automatic differentiation. Any <code>RuleConfig</code> subtype that supports the <a href="api.html#ChainRulesCore.HasReverseMode"><code>HasReverseMode</code></a> special feature must provide an implementation of it.</p><p>See also: <a href="api.html#ChainRulesCore.frule_via_ad"><code>frule_via_ad</code></a>, <a href="api.html#RuleConfig"><code>RuleConfig</code></a> and the documentation on <a href="rule_author/superpowers/ruleconfig.html#config">rule configurations and calling back into AD</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/config.jl#L80-L90">source</a></section></article><h2 id="ProjectTo"><a class="docs-heading-anchor" href="#ProjectTo">ProjectTo</a><a id="ProjectTo-1"></a><a class="docs-heading-anchor-permalink" href="#ProjectTo" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.ProjectTo" href="#ChainRulesCore.ProjectTo"><code>ChainRulesCore.ProjectTo</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(p::ProjectTo{T})(dx)</code></pre><p>Projects the tangent <code>dx</code> onto a specific tangent space.</p><p>The type <code>T</code> is meant to encode the largest acceptable space, so usually this enforces <code>p(dx)::T</code>. But some subspaces which aren&#39;t subtypes of <code>T</code> may be allowed, and in particular <code>dx::AbstractZero</code> always passes through.</p><p>Usually <code>T</code> is the &quot;outermost&quot; part of the type, and <code>p</code> stores additional properties such as projectors for each constituent field. Arrays have either one projector <code>p.element</code> expressing the element type for an array of numbers, or else an array of projectors <code>p.elements</code>. These properties can be supplied as keyword arguments on construction, <code>p = ProjectTo{T}(; field=data, element=Projector(x))</code>. For each <code>T</code> in use, corresponding methods should be written for <code>ProjectTo{T}(dx)</code> with nonzero <code>dx</code>.</p><p>When called on <code>dx::Thunk</code>, the projection is inserted into the thunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/projection.jl#L1-L19">source</a></section></article><h2 id="Ignoring-gradients"><a class="docs-heading-anchor" href="#Ignoring-gradients">Ignoring gradients</a><a id="Ignoring-gradients-1"></a><a class="docs-heading-anchor-permalink" href="#Ignoring-gradients" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.ignore_derivatives" href="#ChainRulesCore.ignore_derivatives"><code>ChainRulesCore.ignore_derivatives</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ignore_derivatives(f::Function)</code></pre><p>Tells the AD system to ignore the gradients of the wrapped closure. The primal computation (forward pass) is executed normally.</p><pre><code class="language-julia hljs">ignore_derivatives() do
    value = rand()
    push!(collection, value)
end</code></pre><p>Using this incorrectly could lead to incorrect gradients. For example, the following function will have zero gradients with respect to its argument:</p><pre><code class="language-julia hljs">function wrong_grads(x)
    y = ones(3)
    ignore_derivatives() do
        push!(y, x)
    end
    return sum(y)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/ignore_derivatives.jl#L1-L25">source</a></section><section><div><pre><code class="language-julia hljs">ignore_derivatives(x)</code></pre><p>Tells the AD system to ignore the gradients of the argument. Can be used to avoid unnecessary computation of gradients.</p><pre><code class="language-julia hljs">ignore_derivatives(x) * w</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/ignore_derivatives.jl#L28-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.@ignore_derivatives" href="#ChainRulesCore.@ignore_derivatives"><code>ChainRulesCore.@ignore_derivatives</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@ignore_derivatives (...)</code></pre><p>Tells the AD system to ignore the expression. Equivalent to <code>ignore_derivatives() do (...) end</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/ignore_derivatives.jl#L42-L46">source</a></section></article><h2 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.AbstractTangent" href="#ChainRulesCore.AbstractTangent"><code>ChainRulesCore.AbstractTangent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractTangent</code></pre><p>The subtypes of <code>AbstractTangent</code> define a custom &quot;algebra&quot; for chain rule evaluation that attempts to factor various features like complex derivative support, broadcast fusion, zero-elision, etc. into nicely separated parts.</p><p>In general a tangent type is the type of a derivative of a value. The type of the value is for contrast called the primal type. Differential types correspond to primal types, although the relation is not one-to-one. Subtypes of  <code>AbstractTangent</code> are not the only tangent types. In fact for the most common primal types, such as <code>Real</code> or <code>AbstractArray{Real}</code> the the tangent type is the same as the primal type.</p><p>In a circular definition: the most important property of a tangent is that it should be able to be added (by defining <code>+</code>) to another tangent of the same primal type. That allows for gradients to be accumulated.</p><p>It generally also should be able to be added to a primal to give back another primal, as this facilitates gradient descent.</p><p>All subtypes of <code>AbstractTangent</code> implement the following operations:</p><ul><li><code>+(a, b)</code>: linearly combine tangent <code>a</code> and tangent <code>b</code></li><li><code>*(a, b)</code>: multiply the tangent <code>b</code> by the scaling factor <code>a</code></li><li><code>Base.zero(x) = ZeroTangent()</code>: a zero.</li></ul><p>Further, they often implement other linear operators, such as <code>conj</code>, <code>adjoint</code>, <code>dot</code>. Pullbacks/pushforwards are linear operators, and their inputs are often <code>AbstractTangent</code> subtypes. Pullbacks/pushforwards in-turn call other linear operators on those inputs. Thus it is desirable to have all common linear operators work on <code>AbstractTangent</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/tangent_types/abstract_tangent.jl#L5-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.debug_mode" href="#ChainRulesCore.debug_mode"><code>ChainRulesCore.debug_mode</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">debug_mode() -&gt; Bool</code></pre><p>Determines if ChainRulesCore is in <code>debug_mode</code>. Defaults to <code>false</code>, but if the user redefines it to return <code>true</code> then extra information will be shown when errors occur.</p><p>Enable via:</p><pre><code class="language-julia hljs">ChainRulesCore.debug_mode() = true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/debug_mode.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.no_rrule" href="#ChainRulesCore.no_rrule"><code>ChainRulesCore.no_rrule</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">no_rrule</code></pre><p>This is an piece of infastructure supporting opting out of <a href="api.html#ChainRulesCore.rrule-Tuple{Any, Vararg{Any, N} where N}"><code>rrule</code></a>. It follows the signature for <code>rrule</code> exactly. A collection of type-tuples is stored in its method-table. If something has this defined, it means that it must having a must also have a <code>rrule</code>,  defined that returns <code>nothing</code>.</p><div class="admonition is-warning" id="Do-not-overload-no_rrule-directly-50f6a15768de24d6"><header class="admonition-header">Do not overload no_rrule directly<a class="admonition-anchor" href="#Do-not-overload-no_rrule-directly-50f6a15768de24d6" title="Permalink"></a></header><div class="admonition-body"><p>It is fine and intended to query the method table of <code>no_rrule</code>. It is not safe to add to that directly, as corresponding changes also need to be made to <code>rrule</code>. The <a href="api.html#ChainRulesCore.@opt_out-Tuple{Any}"><code>@opt_out</code></a> macro does both these things, and so should almost always be used rather than defining a method of <code>no_rrule</code> directly.</p></div></div><p><strong>Mechanics</strong></p><p>note: when the text below says methods <code>==</code> it actually means: <code>parameters(m.sig)[2:end]</code> (i.e. the signature type tuple) rather than the method object <code>m</code> itself.</p><p>To decide if should opt-out using this mechanism.</p><ul><li>find the most specific method of <code>rrule</code> and <code>no_rule</code> e.g with <code>Base.which</code></li><li>if the method of <code>no_rrule</code> <code>==</code> the method of <code>rrule</code>, then should opt-out</li></ul><p>To just ignore the fact that rules can be opted-out from, and that some rules thus return <code>nothing</code>, then filter the list of methods of <code>rrule</code> to remove those that are <code>==</code> to ones that occur in the method table of <code>no_rrule</code>.</p><p>Note also when doing this you must still also handle falling back from rule with config, to rule without config.</p><p>On the other-hand if your AD can work with <code>rrule</code>s that return <code>nothing</code>, then it is simpler to just use that mechanism for opting out; and you don&#39;t need to worry about this at all.</p><p>For more information see the <a href="rule_author/superpowers/opt_out.html#opt_out">documentation on opting out of rules</a></p><p>See also <a href="api.html#ChainRulesCore.no_frule"><code>ChainRulesCore.no_frule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/rules.jl#L188-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChainRulesCore.no_frule" href="#ChainRulesCore.no_frule"><code>ChainRulesCore.no_frule</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">no_frule</code></pre><p>This is an piece of infastructure supporting opting out of <a href="api.html#ChainRulesCore.frule-Tuple{Any, Any, Vararg{Any, N} where N}"><code>frule</code></a>. It follows the signature for <code>frule</code> exactly. A collection of type-tuples is stored in its method-table. If something has this defined, it means that it must having a must also have a <code>frule</code>,  defined that returns <code>nothing</code>.</p><div class="admonition is-warning" id="Do-not-overload-no_frule-directly-7c85fedb1722f1f0"><header class="admonition-header">Do not overload no_frule directly<a class="admonition-anchor" href="#Do-not-overload-no_frule-directly-7c85fedb1722f1f0" title="Permalink"></a></header><div class="admonition-body"><p>It is fine and intended to query the method table of <code>no_frule</code>. It is not safe to add to that directly, as corresponding changes also need to be made to <code>frule</code>. The <a href="api.html#ChainRulesCore.@opt_out-Tuple{Any}"><code>@opt_out</code></a> macro does both these things, and so should almost always be used rather than defining a method of <code>no_frule</code> directly.</p></div></div><p><strong>Mechanics</strong></p><p>note: when the text below says methods <code>==</code> it actually means: <code>parameters(m.sig)[2:end]</code> (i.e. the signature type tuple) rather than the method object <code>m</code> itself.</p><p>To decide if should opt-out using this mechanism.</p><ul><li>find the most specific method of <code>frule</code> and <code>no_rule</code> e.g with <code>Base.which</code></li><li>if the method of <code>no_frule</code> <code>==</code> the method of <code>frule</code>, then should opt-out</li></ul><p>To just ignore the fact that rules can be opted-out from, and that some rules thus return <code>nothing</code>, then filter the list of methods of <code>frule</code> to remove those that are <code>==</code> to ones that occur in the method table of <code>no_frule</code>.</p><p>Note also when doing this you must still also handle falling back from rule with config, to rule without config.</p><p>On the other-hand if your AD can work with <code>frule</code>s that return <code>nothing</code>, then it is simpler to just use that mechanism for opting out; and you don&#39;t need to worry about this at all.</p><p>For more information see the <a href="rule_author/superpowers/opt_out.html#opt_out">documentation on opting out of rules</a></p><p>See also <a href="api.html#ChainRulesCore.no_rrule"><code>ChainRulesCore.no_rrule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/69bedfd739c97349b6e2b756191ed847755d3cc4/src/rules.jl#L196-L232">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="FAQ.html">« FAQ</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 9 August 2025 14:35">Saturday 9 August 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

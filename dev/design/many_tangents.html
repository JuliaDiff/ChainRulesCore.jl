<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Many Tangent Types · ChainRules</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.svg" alt="ChainRules logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">ChainRules</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><span class="tocitem">How to use ChainRules as a rule author</span><ul><li><a class="tocitem" href="../rule_author/intro.html">Introduction</a></li><li><a class="tocitem" href="../rule_author/example.html">Pedagogical example</a></li><li><a class="tocitem" href="../rule_author/tangents.html">Tangent types</a></li><li><a class="tocitem" href="../rule_author/which_functions_need_rules.html">Which functions need rules?</a></li><li><a class="tocitem" href="../rule_author/rule_definition_tools.html">Rule definition tools</a></li><li><a class="tocitem" href="../rule_author/writing_good_rules.html">Writing good rules</a></li><li><a class="tocitem" href="../rule_author/testing.html">Testing your rules</a></li><li><input class="collapse-toggle" id="menuitem-2-8" type="checkbox"/><label class="tocitem" for="menuitem-2-8"><span class="docs-label">Superpowers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../rule_author/superpowers/projectto.html"><code>ProjectTo</code></a></li><li><a class="tocitem" href="../rule_author/superpowers/opt_out.html"><code>@opt_out</code></a></li><li><a class="tocitem" href="../rule_author/superpowers/ruleconfig.html"><code>RuleConfig</code></a></li><li><a class="tocitem" href="../rule_author/superpowers/gradient_accumulation.html">Gradient accumulation</a></li></ul></li><li><a class="tocitem" href="../rule_author/converting_zygoterules.html">Converting ZygoteRules.@adjoint to rrules</a></li><li><a class="tocitem" href="../rule_author/tips_for_packages.html">Tips for making your package work with AD</a></li><li><a class="tocitem" href="../rule_author/debug_mode.html">Debug mode</a></li></ul></li><li><span class="tocitem">How to support ChainRules rules as an AD package author</span><ul><li><a class="tocitem" href="../ad_author/use_in_ad_system.html">Usage in AD</a></li><li><a class="tocitem" href="../ad_author/call_back_into_ad.html">Suport calling back into ADs</a></li><li><a class="tocitem" href="../ad_author/opt_out.html">Support opting out of rules</a></li></ul></li><li><span class="tocitem">The maths</span><ul><li><a class="tocitem" href="../maths/propagators.html">The propagators: pushforward and pullback</a></li><li><a class="tocitem" href="../maths/nondiff_points.html">Non-differentiable Points</a></li><li><a class="tocitem" href="../maths/complex.html">Complex numbers</a></li><li><a class="tocitem" href="../maths/arrays.html">Deriving array rules</a></li></ul></li><li><span class="tocitem">Design</span><ul><li><a class="tocitem" href="changing_the_primal.html">Changing the Primal</a></li><li class="is-active"><a class="tocitem" href="many_tangents.html">Many Tangent Types</a><ul class="internal"><li><a class="tocitem" href="#Natural-tangent"><span>Natural tangent</span></a></li><li><a class="tocitem" href="#Structural-tangent-types"><span>Structural tangent types</span></a></li><li><a class="tocitem" href="#Semi-structural-tangents"><span>Semi-structural tangents</span></a></li><li><a class="tocitem" href="#Tangent-types-for-computational-efficiency"><span>Tangent types for computational efficiency</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li><li><a class="tocitem" href="#Appendix:-What-Swift-does"><span>Appendix: What Swift does</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../videos.html">Videos</a></li><li><a class="tocitem" href="../FAQ.html">FAQ</a></li><li><a class="tocitem" href="../api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Design</a></li><li class="is-active"><a href="many_tangents.html">Many Tangent Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="many_tangents.html">Many Tangent Types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/main/docs/src/design/many_tangents.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="manytypes"><a class="docs-heading-anchor" href="#manytypes">Design Notes: The many-to-many relationship between tangent types and primal types</a><a id="manytypes-1"></a><a class="docs-heading-anchor-permalink" href="#manytypes" title="Permalink"></a></h1><p>ChainRules has a system where one primal type (the type having its derivative taken) can have multiple possible tangent types (the type of the derivative); and where one tangent type can correspond to multiple primal types. This is in-contrast to the Swift AD efforts, which has one tangent type per primal type (Swift uses the term associated tangent type).</p><div class="admonition is-category-terminology"><header class="admonition-header">tangent and associated tangent type</header><div class="admonition-body"><p>The use of “associated tangent type” in AD is not technically correct, as they live in the <a href="https://en.wikipedia.org/wiki/Cotangent_space"><em>cotangent</em> plane</a> instead of the <a href="https://en.wikipedia.org/wiki/Tangent_space">tangent plane</a>. However it is often reasonable for AD to treat the cotangent plane and tangent plane as the same thing, and this was an intentional choice by the Swift team. In ChainRules we use the term “tangent type” to refer to both tangents and cotangents.</p></div></div><p>One thing to understand about tangents is that they have to form a <a href="https://en.wikipedia.org/wiki/Vector_space">vector space</a>  (or something very like them). They need to support addition to each other, they need a zero which doesn&#39;t change what it is added to, and they need to support scalar multiplication (this isn&#39;t really required, but it is handy for things like gradient descent). Beyond being a vector space, tangents need to be able to be added to a primal value to get back another primal value. Or roughly equivalently a tangent is a difference between two primal values.</p><p>One thing to note in this example is that the primal does not have to be a vector. As an example, consider <code>DateTime</code>. A <code>DateTime</code> is not a vector space: there is no origin point, and <code>DateTime</code>s cannot be added to each other. The corresponding tangent type is any subtype of <code>Period</code>, such as <code>Millisecond</code>, <code>Hour</code>, <code>Day</code> etc.</p><h2 id="Natural-tangent"><a class="docs-heading-anchor" href="#Natural-tangent">Natural tangent</a><a id="Natural-tangent-1"></a><a class="docs-heading-anchor-permalink" href="#Natural-tangent" title="Permalink"></a></h2><p>For a given primal type, we say a natural tangent type is one which people would intuitively think of as representing the difference between two primal values. It tends to already exist outside of the context of AD. So <code>Millisecond</code>, <code>Hour</code>, <code>Day</code> etc. are examples of <em>natural tangents</em> for the <code>DateTime</code> primal.</p><p>Note here that we already have a one primal type to many tangent types relationship. We have <code>Millisecond</code> and <code>Hour</code> and <code>Day</code> all being valid tangent types for <code>DateTime</code>. In this case we <em>could</em> convert them all to a single tangent type, such as <code>Nanoseconds</code>, but that is not always a reasonable decision: we may run in to overflow, or lots of allocations if we need to use a <code>BigInt</code> to represent the number of <code>Nanosecond</code> since the start of the universe. For types with more complex semantics, such as array types, these considerations are much more important.</p><p>Natural tangent types are the types people tend to think in, and thus the type they tend to write custom sensitivity rules in. An important special case of natural tangents is when the primal type is a vector space (e.g. <code>Real</code>,<code>AbstractMatrix</code>) in which case it is <em>common</em> for the natural tangent type to be the same as the primal type. One exception to this is <code>getindex</code>. The ideal choice of tangent type for <code>getindex</code> on a dense array would be some type of sparse array, due to the fact the derivative will have only one non-zero element. This actually further brings us to a weirdness of tangent types not actually being closed under addition, as it would be ideal for the sparse array to become a dense array if summed over all elements.</p><h2 id="Structural-tangent-types"><a class="docs-heading-anchor" href="#Structural-tangent-types">Structural tangent types</a><a id="Structural-tangent-types-1"></a><a class="docs-heading-anchor-permalink" href="#Structural-tangent-types" title="Permalink"></a></h2><p>AD cannot automatically determine the natural tangent types for a primal. For some types we may be able to declare manually their natural tangent type. Other types will not have natural tangent types at all - e.g. <code>NamedTuple</code>, <code>Tuple</code>, <code>WebServer</code>, <code>Flux.Dense</code> -  so we are destined to make some up. So beyond <em>natural</em> tangent types, we also have <em>structural</em> tangent types. ChainRules uses <a href="../api.html#ChainRulesCore.Tangent"><code>Tangent{P, &lt;:NamedTuple}</code></a> to represent a structural tangent type corresponding to primal type <code>P</code>. <a href="https://github.com/FluxML/Zygote.jl/">Zygote</a> v0.4 uses <code>NamedTuple</code>.</p><p>Structural tangents are derived from the structure of the input. Either automatically, as part of the AD, or manually, as part of a custom rule.</p><p>Consider the structure of <code>DateTime</code>:</p><pre><code class="language-julia hljs">julia&gt; dump(now())
DateTime
  instant: UTInstant{Millisecond}
    periods: Millisecond
      value: Int64 63719890305605</code></pre><p>The corresponding structural tangent is:</p><pre><code class="language-julia hljs">Tangent{DateTime}(
    instant::Tangent{UTInstant{Millisecond}}(
        periods::Tangent{Millisecond}(
            value::Int64
        )
    )
)</code></pre><div class="admonition is-info"><header class="admonition-header">One must be allowed to take derivatives of integer arguments</header><div class="admonition-body"><p>This brings up another contrast to Swift. In Swift <code>Int</code> is considered non-differentiable, which is quite reasonable; it doesn’t have a very good definition of the limit of a small step (as that would be some floating/fixed point type). <code>Int</code> is intrinsically discrete. It is commonly used for indexing, and if one takes a gradient step, say turning <code>x[2]</code> into <code>x[2.1]</code> then that is an error. However, disallowing <code>Int</code> to be used as a tangent means we cannot handle cases like <code>DateTime</code> having an inner field of milliseconds counted as an integer from the unix epoch or other cases where an integer is used as a convenience for computational efficiency. In the case where a custom sensitivity rule claims that there is a non-zero derivative for an <code>Int</code> argument that is being used for indexing, that code is simply wrong. We can’t handle incorrect code and trying to is a path toward madness. Julia, unlike Swift, is not well suited to handling rules about what you can and can’t do with particular types.</p></div></div><p>So the structural tangent is another type of tangent. We must support both natural and structural tangents because AD can only create structural tangents (unless using custom sensitivity rules) and all custom sensitivities are only written in terms of natural tangents, as that is what is used in papers about derivatives.</p><h2 id="Semi-structural-tangents"><a class="docs-heading-anchor" href="#Semi-structural-tangents">Semi-structural tangents</a><a id="Semi-structural-tangents-1"></a><a class="docs-heading-anchor-permalink" href="#Semi-structural-tangents" title="Permalink"></a></h2><p>Where there is no natural tangent type for the outermost type but there is for some of its fields, we call this a &quot;semi-structural&quot; tangent.</p><p>Consider if we had a representation of a country&#39;s GDP as output by some continuous time model like a Gaussian Process, where that representation is as a sequence of <code>TimeSample</code>s structured as follows:</p><pre><code class="language-julia hljs">julia&gt; struct TimeSample
           time::DateTime
           value::Float64
       end</code></pre><p>We can look at its structure:</p><pre><code class="language-julia hljs">julia&gt; dump(TimeSample(now(), 2.6e9))
TimeSample
  time: DateTime
    instant: Dates.UTInstant{Millisecond}
      periods: Millisecond
        value: Int64 63720043490844
  value: Float64 2.6e9</code></pre><p>Thus we see the that structural tangent would be:</p><pre><code class="language-julia hljs">Tangent{TimeSample}(
    time::Tangent{DateTime}(
        instant::Tangent{UTInstant{Millisecond}}(
            periods::Tangent{Millisecond}(
                value::Int64
            )
        )
    ),
    value::Float64
)</code></pre><p>But instead in the custom sensitivity rule we would write a semi-structured tangent type. Since there is not a natural tangent type for <code>TimeSample</code> but there is for <code>DateTime</code>.</p><pre><code class="language-julia hljs">Tangent{TimeSample}(
    time::Day,
    value::Float64
)</code></pre><p>So the rule author has written a structural tangent with some fields that are natural tangents.</p><p>Another related case is for types that overload <code>getproperty</code> such as <code>SVD</code> and <code>QR</code>. In this case the structural tangent will be based on the fields, but those fields do not always have an easy relation to what is actually used in math. For example, the <code>QR</code> type has fields <code>factors</code> and <code>t</code>, but we would more naturally think in terms of the properties <code>Q</code> and <code>R</code>. So most rule authors would want to write semi-structural tangents based on the properties.</p><p>To return to the question of why ChainRules has <code>Tangent{P, &lt;:NamedTuple}</code> whereas Zygote v0.4 just has <code>NamedTuple</code>, it relates to semi-structural derivatives, and being able to overload things more generally. If one knows that one has a semi-structural derivative based on property names, like <code>Tangent{QR}(Q=..., R=...)</code>, and one is adding it to the true structural derivative based on field names <code>Tangent{QR}(factors=..., τ=...)</code>, then we need to overload the addition operator to perform that correctly. We cannot happily overload similar things for <code>NamedTuple</code> since we don&#39;t know the primal type, only the names of the values contained. In fact we can&#39;t actually overload addition at all for <code>NamedTuple</code> as that would be type-piracy, so have to use <code>Zygote.accum</code> instead.</p><p>Another use of the primal being a type parameter is to catch errors. ChainRules disallows the addition of <code>Tangent{SVD}</code> to <code>Tangent{QR}</code> since in a correctly differentiated program that can never occur.</p><h2 id="Tangent-types-for-computational-efficiency"><a class="docs-heading-anchor" href="#Tangent-types-for-computational-efficiency">Tangent types for computational efficiency</a><a id="Tangent-types-for-computational-efficiency-1"></a><a class="docs-heading-anchor-permalink" href="#Tangent-types-for-computational-efficiency" title="Permalink"></a></h2><p>There is another kind of unnatural tangent. One that is for computational efficiency. ChainRules has <a href="../api.html#ChainRulesCore.Thunk"><code>Thunk</code></a>s and <a href="../api.html#ChainRulesCore.InplaceableThunk"><code>InplaceableThunk</code></a>s, which wrap the computation of a derivative and delays that work until it is needed, either via the derivative being added to something or being <a href="../api.html#ChainRulesCore.unthunk-Tuple{Any}"><code>unthunk</code></a>ed manually, thus saving time if it is never used.</p><p>Another tangent type used for efficiency is <a href="../api.html#ChainRulesCore.ZeroTangent"><code>ZeroTangent</code></a> which represents the hard zero (in Zygote v0.4 this is <code>nothing</code>). For example the derivative of <code>f(x, y)=2x</code> with respect to <code>y</code> is <code>ZeroTangent()</code>. Add <code>ZeroTangent()</code> to anything, and one gets back the original thing without change. We noted that all tangents need to be a vector space.  <code>ZeroTangent()</code> is the <a href="https://proofwiki.org/wiki/Definition:Trivial_Vector_Space">trivial vector space</a>. Further, add <code>ZeroTangent()</code> to any primal value (no matter the type) and you get back another value of the same primal type (the same value in fact). So it meets the requirements of a tangent type for <em>all</em> primal types. <code>ZeroTangent</code> can save on memory (since we can avoid allocating anything) and on time (since performing the multiplication <code>ZeroTangent</code> and <code>Thunk</code> are both examples of a tangent type that is valid for multiple primal types.</p><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><p>Now, you have seen examples of both tangent types that work for multiple primal types, and primal types that have  multiple valid tangent types. Semantically we can handle these very easily in julia. Just put in a few more dispatching on <code>+</code>. Multiple-dispatch is great like that. The down-side is our type-inference becomes hard. If you have exactly 1 tangent type for each primal type, you can very easily workout what all the types on your reverse pass will be - you don&#39;t really need type inference - but you lose so much expressibility.</p><h2 id="Appendix:-What-Swift-does"><a class="docs-heading-anchor" href="#Appendix:-What-Swift-does">Appendix: What Swift does</a><a id="Appendix:-What-Swift-does-1"></a><a class="docs-heading-anchor-permalink" href="#Appendix:-What-Swift-does" title="Permalink"></a></h2><p>I don&#39;t know how Swift is handling thunks, maybe they are not, maybe they have an optimizing compiler that can just slice out code-paths that don&#39;t lead to values that get used; maybe they have a language built in for lazy computation.</p><p>They are, as I understand it, handling <code>ZeroTangent</code> by requiring every tangent type to define a <code>zero</code> method – which it has since it is a vector space. This costs memory and time, but probably not actually all that much. With regards to handling multiple different tangent types for one primal, like natural and structural derivatives, everything needs to be converted to the <em>canonical</em> tangent type of that primal.</p><p>As I understand it, things can be automatically converted by defining conversion protocols or something like that, so rule authors can return anything that has a conversion protocol to the canonical tangent type of the primal.</p><p>However, it seems like this will run into problems. Recall that the natural tangent in the case of <code>getindex</code> on an <code>AbstractArray</code> was a sparse array. But for say the standard dense <code>Array</code>, the only reasonable canonical tangent type is also a dense <code>Array</code>. But if you convert a sparse array into a dense array you do giant allocations to fill in all the other entries with zero.</p><p>So this is the story about why we have many-to-many tangent types in ChainRules.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="changing_the_primal.html">« Changing the Primal</a><a class="docs-footer-nextpage" href="../videos.html">Videos »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Thursday 16 February 2023 02:45">Thursday 16 February 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gradient accumulation · ChainRules</title><meta name="title" content="Gradient accumulation · ChainRules"/><meta property="og:title" content="Gradient accumulation · ChainRules"/><meta property="twitter:title" content="Gradient accumulation · ChainRules"/><meta name="description" content="Documentation for ChainRules."/><meta property="og:description" content="Documentation for ChainRules."/><meta property="twitter:description" content="Documentation for ChainRules."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img src="../../assets/logo.svg" alt="ChainRules logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../index.html">ChainRules</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../index.html">Introduction</a></li><li><span class="tocitem">How to use ChainRules as a rule author</span><ul><li><a class="tocitem" href="../intro.html">Introduction</a></li><li><a class="tocitem" href="../example.html">Pedagogical example</a></li><li><a class="tocitem" href="../tangents.html">Tangent types</a></li><li><a class="tocitem" href="../which_functions_need_rules.html">Which functions need rules?</a></li><li><a class="tocitem" href="../rule_definition_tools.html">Rule definition tools</a></li><li><a class="tocitem" href="../writing_good_rules.html">Writing good rules</a></li><li><a class="tocitem" href="../testing.html">Testing your rules</a></li><li><input class="collapse-toggle" id="menuitem-2-8" type="checkbox" checked/><label class="tocitem" for="menuitem-2-8"><span class="docs-label">Superpowers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="projectto.html"><code>ProjectTo</code></a></li><li><a class="tocitem" href="opt_out.html"><code>@opt_out</code></a></li><li><a class="tocitem" href="ruleconfig.html"><code>RuleConfig</code></a></li><li class="is-active"><a class="tocitem" href="gradient_accumulation.html">Gradient accumulation</a></li><li><a class="tocitem" href="mutation_support.html">Mutation Support (experimental)</a></li></ul></li><li><a class="tocitem" href="../converting_zygoterules.html">Converting ZygoteRules.@adjoint to rrules</a></li><li><a class="tocitem" href="../tips_for_packages.html">Tips for making your package work with AD</a></li><li><a class="tocitem" href="../debug_mode.html">Debug mode</a></li></ul></li><li><span class="tocitem">How to support ChainRules rules as an AD package author</span><ul><li><a class="tocitem" href="../../ad_author/use_in_ad_system.html">Usage in AD</a></li><li><a class="tocitem" href="../../ad_author/call_back_into_ad.html">Support calling back into ADs</a></li><li><a class="tocitem" href="../../ad_author/opt_out.html">Support opting out of rules</a></li></ul></li><li><span class="tocitem">The maths</span><ul><li><a class="tocitem" href="../../maths/propagators.html">The propagators: pushforward and pullback</a></li><li><a class="tocitem" href="../../maths/nondiff_points.html">Non-differentiable Points</a></li><li><a class="tocitem" href="../../maths/complex.html">Complex numbers</a></li><li><a class="tocitem" href="../../maths/arrays.html">Deriving array rules</a></li></ul></li><li><span class="tocitem">Design</span><ul><li><a class="tocitem" href="../../design/changing_the_primal.html">Changing the Primal</a></li><li><a class="tocitem" href="../../design/many_tangents.html">Many Tangent Types</a></li></ul></li><li><a class="tocitem" href="../../videos.html">Videos</a></li><li><a class="tocitem" href="../../FAQ.html">FAQ</a></li><li><a class="tocitem" href="../../api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to use ChainRules as a rule author</a></li><li><a class="is-disabled">Superpowers</a></li><li class="is-active"><a href="gradient_accumulation.html">Gradient accumulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="gradient_accumulation.html">Gradient accumulation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDiff/ChainRulesCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/main/docs/src/rule_author/superpowers/gradient_accumulation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="grad_acc"><a class="docs-heading-anchor" href="#grad_acc">Gradient Accumulation</a><a id="grad_acc-1"></a><a class="docs-heading-anchor-permalink" href="#grad_acc" title="Permalink"></a></h1><p>Consider some function <span>$f(x) = g(x) + h(x)$</span>. If we would like the derivative of <span>$f$</span> with respect to <span>$x$</span> we must compute it for each part and then sum them, i.e. <span>$\frac{\partial f}{\partial x} = \frac{\partial g}{\partial x} + \frac{\partial h}{\partial x}$</span>. In general, we must accumulate (sum) gradients from each sub-part of a program where a variable is used.</p><p>Consider for example:</p><pre><code class="language-julia hljs">function sum_first_and_second(X::Array{Float64})
    a = X[1]
    b = X[2]
    y = a + b
    return y
end</code></pre><p>The AD software must transform that into something which repeatedly sums up the gradient of each part: <code>X̄ = ā + b̄</code>.</p><p>This requires that all tangent types <code>D</code> must implement <code>+</code>: <code>+(::D, ::D)::D</code>.</p><p>We can note that in this particular case <code>ā</code> and <code>b̄</code> will both be arrays. This operation (<code>X̄ = ā + b̄</code>) will allocate one array to hold <code>ā</code>, another one to hold <code>b̄</code>, and a third one to hold <code>ā + b̄</code>. This is three allocations. Allocations are not free, they increase the time the program takes to run by a nontrivial amount, even with a good allocator and a good garbage collector.</p><h3 id="Maybe-mutating-accumulation-(add!!)"><a class="docs-heading-anchor" href="#Maybe-mutating-accumulation-(add!!)">Maybe-mutating accumulation (<code>add!!</code>)</a><a id="Maybe-mutating-accumulation-(add!!)-1"></a><a class="docs-heading-anchor-permalink" href="#Maybe-mutating-accumulation-(add!!)" title="Permalink"></a></h3><p>We can note that in the above that neither <code>ā</code> nor <code>b̄</code> are ever used again after accumulating to get <code>X̄</code>. Furthermore, <code>Array</code>s are mutable. That means we could over-write either <code>ā</code> or <code>b̄</code> and use the result as <code>X̄</code>:</p><pre><code class="language-julia hljs">ā .+= b̄
X̄ = ā</code></pre><p>This cuts our allocations down to 2, just <code>ā</code> and <code>b̄</code>.</p><p>However, we have a bit of a problem that not all types are mutable, so this pattern is hard to apply in general. To deal with that ChainRulesCore provides <a href="../../api.html#ChainRulesCore.add!!"><code>add!!</code></a>. Per the <a href="https://github.com/JuliaFolds/BangBang.jl">BangBang.jl</a> convention, this is a maybe mutating addition. It may mutate its first argument (if it is mutable), but it will definitely return the correct result. We would write using that as <code>X̄ = add!!(ā, b̄)</code>: which would in this case give us just 2 allocations. AD systems can generate <code>add!!</code> instead of <code>+</code> when accumulating gradient to take advantage of this.</p><h3 id="Inplaceable-Thunks-(InplaceableThunks)-avoid-allocating-values-in-the-first-place."><a class="docs-heading-anchor" href="#Inplaceable-Thunks-(InplaceableThunks)-avoid-allocating-values-in-the-first-place.">Inplaceable Thunks (<code>InplaceableThunks</code>) avoid allocating values in the first place.</a><a id="Inplaceable-Thunks-(InplaceableThunks)-avoid-allocating-values-in-the-first-place.-1"></a><a class="docs-heading-anchor-permalink" href="#Inplaceable-Thunks-(InplaceableThunks)-avoid-allocating-values-in-the-first-place." title="Permalink"></a></h3><p>We got down to two allocations from using <a href="../../api.html#ChainRulesCore.add!!"><code>add!!</code></a>, but can we do better? We can think of having a tangent type which acts on a partially accumulated result, to mutate it to contain its current value plus the partial derivative being accumulated. Rather than having an actual computed value, we can just have a thing that will act on a value to perform the addition. Let&#39;s illustrate it with our example.</p><p><code>b̄</code> is the partial for <code>X[2]</code> and its value can be computed by:</p><pre><code class="language-julia hljs">b̄ = zeros(size(X))
b̄[2] = ȳ  # the scalar sensitivity of the `sum_first_and_second` output</code></pre><p><code>b̄</code> is a matrix entirely of zeros, except for at the index <code>2</code>, where it is set to the output sensitivity <code>ȳ</code>. <code>ā</code> is similar, except with the non-zero at index <code>1</code>.</p><p>What is the action of <code>b̄</code> upon <code>ā</code>, to get the same result as <code>X̄ = add!!(ā, b̄)</code> (or <code>X̄ = ā + b̄</code> for that matter)? It is:</p><pre><code class="language-julia hljs">function b̄_add!(ā)
    ā[2] += ȳ
    return ā
end</code></pre><p>We don&#39;t need to worry about all those zeros since <code>x + 0 == x</code>.</p><p><a href="../../api.html#ChainRulesCore.InplaceableThunk"><code>InplaceableThunk</code></a> is the type we have to represent derivatives as gradient accumulating actions. We must note that to do this we do need a value form of <code>ā</code> for <code>b̄</code> to act upon. For this reason every inplaceable thunk has both a <code>val</code> field holding the value representation, and a <code>add!</code> field holding the action representation. The <code>val</code> field use a plain <a href="../../api.html#ChainRulesCore.Thunk"><code>Thunk</code></a> to avoid the computation (and thus allocation) if it is unused.</p><div class="admonition is-info"><header class="admonition-header">Do we need both representations?</header><div class="admonition-body"><p>Right now every <a href="../../api.html#ChainRulesCore.InplaceableThunk"><code>InplaceableThunk</code></a> has two fields that need to be specified. The value form (represented as a the <a href="../../api.html#ChainRulesCore.Thunk"><code>Thunk</code></a> typed field), and the action form (represented as the <code>add!</code> field). It is possible in a future version of ChainRulesCore.jl we will work out a clever way to find the zero tangent for arbitrary primal values. Given that, we could always just determine the value form from <code>inplaceable.add!(zero_tangent(primal))</code>. There are some technical difficulties in finding the zero tangents, but this may be solved at some point.</p></div></div><p>The <code>+</code> operation on <code>InplaceableThunk</code>s is overloaded to <a href="../../api.html#ChainRulesCore.unthunk-Tuple{Any}"><code>unthunk</code></a> that <code>val</code> field to get the value form. Where as the <a href="../../api.html#ChainRulesCore.add!!"><code>add!!</code></a> operation is overloaded to call <code>add!</code> to invoke the action.</p><p>With <code>getindex</code> defined to return an <code>InplaceableThunk</code>, we now get to <code>X̄ = add!!(ā, b̄)</code> requires only a single allocation. This allocation occurs when <code>unthunk</code>ing <code>ā</code>, which is then mutated to become <code>X̄</code>. This is basically as good as we can get: if we want <code>X̄</code> to be an <code>Array</code> then at some point we need to allocate that array.</p><div class="admonition is-info"><header class="admonition-header">Can we do more? Deferred accumulation</header><div class="admonition-body"><p>We could keep going further to drop allocations if we really wanted. If we didn&#39;t care about <code>X̄</code> being an <code>Array</code> then we could defer its computation too. <code>X̄ = @thunk add!!(ā, b̄)</code>. This kind of deferral will work fine and you can keep chaining it. It does start to burn stack space, and might make the compiler&#39;s optimization passes cry. But it&#39;s valid and should work fine.</p></div></div><h3 id="Examples-of-InplaceableThunks"><a class="docs-heading-anchor" href="#Examples-of-InplaceableThunks">Examples of InplaceableThunks</a><a id="Examples-of-InplaceableThunks-1"></a><a class="docs-heading-anchor-permalink" href="#Examples-of-InplaceableThunks" title="Permalink"></a></h3><h4 id="getindex"><a class="docs-heading-anchor" href="#getindex"><code>getindex</code></a><a id="getindex-1"></a><a class="docs-heading-anchor-permalink" href="#getindex" title="Permalink"></a></h4><p>The aforementioned <code>getindex</code> is really the poster child for this. Consider something like:</p><pre><code class="language-julia hljs">function mysum(X::Array{Float64})
    total = 0.0
    for i in eachindex(X)
        total += X[i]
    end
    return total
end</code></pre><p>If one only has value representation of derivatives one ends up having to allocate a derivative array for every single element of the original array <code>X</code>. That&#39;s terrible. On the other hand, with the action representation that <code>InplaceableThunk</code>s provide, there is just a single <code>Array</code> allocated. One can see <a href="https://github.com/JuliaDiff/ChainRules.jl/blob/v0.7.49/src/rulesets/Base/indexing.jl">the <code>getindex</code> rule in ChainRules.jl for the implementation</a>.</p><h4 id="matmul-etc-(*)"><a class="docs-heading-anchor" href="#matmul-etc-(*)">matmul etc (<code>*</code>)</a><a id="matmul-etc-(*)-1"></a><a class="docs-heading-anchor-permalink" href="#matmul-etc-(*)" title="Permalink"></a></h4><p>Multiplication of scalars/vectors/matrices of compatible dimensions can all also have their derivatives represented as an <code>InplaceableThunk</code>. These tend to pivot around that <code>add!</code> action being defined along the lines of: <code>X̄ -&gt; mul!(X̄, A&#39;, Ȳ, true, true)</code>. Where 5-arg <code>mul!</code> is the in place <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.mul!">multiply-add operation</a>. <code>mul!(X̄, A&#39;, Ȳ, true, true)</code> has the same effect as <code>(X̄ .+= A&#39;*Ȳ)</code> but avoids allocating  the matrix  <code>A&#39;*Ȳ</code> This is one of the fundamental operations provided by BLAS – including the application of the conjugate transpose. e.g. the Matrix-Matrix form is <a href="http://www.netlib.org/lapack/explore-html/d1/d54/group__double__blas__level3_gaeda3cbd99c8fb834a60a6412878226e1.html#gaeda3cbd99c8fb834a60a6412878226e1"><code>GEMM</code> (GEneralized Matrix-Matrix Multiplication)</a>, the Matrix-Vector form is <a href="http://www.netlib.org/lapack/explore-html/d7/d15/group__double__blas__level2_gadd421a107a488d524859b4a64c1901a9.html#gadd421a107a488d524859b4a64c1901a9"><code>GEMV</code> (GEneralized Matrix-Vector Multiplication)</a> etc. Under the hood doing it out of place is going to call one of these methods anyway, but on a freshly allocated output array. So we are going to hit a very efficient implementation and get the addition for free.</p><p>One can see <a href="https://github.com/JuliaDiff/ChainRules.jl/blob/v0.7.49/src/rulesets/Base/arraymath.jl#L22-L95">the <code>*</code> rules in ChainRules.jl for the implementations</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="ruleconfig.html">« <code>RuleConfig</code></a><a class="docs-footer-nextpage" href="mutation_support.html">Mutation Support (experimental) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Sunday 22 June 2025 19:17">Sunday 22 June 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

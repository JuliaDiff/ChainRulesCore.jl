<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Writing good rules · ChainRules</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.svg" alt="ChainRules logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">ChainRules</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><span class="tocitem">How to use ChainRules as a rule author</span><ul><li><a class="tocitem" href="intro.html">Introduction</a></li><li><a class="tocitem" href="example.html">Pedagogical example</a></li><li><a class="tocitem" href="tangents.html">Tangent types</a></li><li><a class="tocitem" href="which_functions_need_rules.html">Which functions need rules?</a></li><li><a class="tocitem" href="rule_definition_tools.html">Rule definition tools</a></li><li class="is-active"><a class="tocitem" href="writing_good_rules.html">Writing good rules</a><ul class="internal"><li><a class="tocitem" href="#Code-Style"><span>Code Style</span></a></li><li><a class="tocitem" href="#Use-ZeroTangent()-as-the-return-value"><span>Use <code>ZeroTangent()</code> as the return value</span></a></li><li><a class="tocitem" href="#Use-Thunks-appropriately"><span>Use <code>Thunk</code>s appropriately</span></a></li><li><a class="tocitem" href="#structs"><span>Structs: constructors and functors</span></a></li><li><a class="tocitem" href="#Ensure-your-pullback-can-accept-the-right-types"><span>Ensure your pullback can accept the right types</span></a></li><li><a class="tocitem" href="#Use-@not_implemented-appropriately"><span>Use <code>@not_implemented</code> appropriately</span></a></li><li><a class="tocitem" href="#Use-rule-definition-tools"><span>Use rule definition tools</span></a></li><li><a class="tocitem" href="#Be-careful-about-pullback-closures-calling-other-methods-of-themselves"><span>Be careful about pullback closures calling other methods of themselves</span></a></li><li><a class="tocitem" href="#CAS-systems-are-your-friends."><span>CAS systems are your friends.</span></a></li></ul></li><li><a class="tocitem" href="testing.html">Testing your rules</a></li><li><input class="collapse-toggle" id="menuitem-2-8" type="checkbox"/><label class="tocitem" for="menuitem-2-8"><span class="docs-label">Superpowers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="superpowers/projectto.html"><code>ProjectTo</code></a></li><li><a class="tocitem" href="superpowers/opt_out.html"><code>@opt_out</code></a></li><li><a class="tocitem" href="superpowers/ruleconfig.html"><code>RuleConfig</code></a></li><li><a class="tocitem" href="superpowers/gradient_accumulation.html">Gradient accumulation</a></li></ul></li><li><a class="tocitem" href="converting_zygoterules.html">Converting ZygoteRules.@adjoint to rrules</a></li><li><a class="tocitem" href="tips_for_packages.html">Tips for making your package work with AD</a></li><li><a class="tocitem" href="debug_mode.html">Debug mode</a></li></ul></li><li><span class="tocitem">How to support ChainRules rules as an AD package author</span><ul><li><a class="tocitem" href="../ad_author/use_in_ad_system.html">Usage in AD</a></li><li><a class="tocitem" href="../ad_author/call_back_into_ad.html">Suport calling back into ADs</a></li><li><a class="tocitem" href="../ad_author/opt_out.html">Support opting out of rules</a></li></ul></li><li><span class="tocitem">The maths</span><ul><li><a class="tocitem" href="../maths/propagators.html">The propagators: pushforward and pullback</a></li><li><a class="tocitem" href="../maths/nondiff_points.html">Non-differentiable Points</a></li><li><a class="tocitem" href="../maths/complex.html">Complex numbers</a></li><li><a class="tocitem" href="../maths/arrays.html">Deriving array rules</a></li></ul></li><li><span class="tocitem">Design</span><ul><li><a class="tocitem" href="../design/changing_the_primal.html">Changing the Primal</a></li><li><a class="tocitem" href="../design/many_tangents.html">Many Tangent Types</a></li></ul></li><li><a class="tocitem" href="../videos.html">Videos</a></li><li><a class="tocitem" href="../FAQ.html">FAQ</a></li><li><a class="tocitem" href="../api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to use ChainRules as a rule author</a></li><li class="is-active"><a href="writing_good_rules.html">Writing good rules</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="writing_good_rules.html">Writing good rules</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/main/docs/src/rule_author/writing_good_rules.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="On-writing-good-rrule-/-frule-methods"><a class="docs-heading-anchor" href="#On-writing-good-rrule-/-frule-methods">On writing good <code>rrule</code> / <code>frule</code> methods</a><a id="On-writing-good-rrule-/-frule-methods-1"></a><a class="docs-heading-anchor-permalink" href="#On-writing-good-rrule-/-frule-methods" title="Permalink"></a></h1><h2 id="Code-Style"><a class="docs-heading-anchor" href="#Code-Style">Code Style</a><a id="Code-Style-1"></a><a class="docs-heading-anchor-permalink" href="#Code-Style" title="Permalink"></a></h2><p>Use named local functions for the <code>pullback</code> in an <code>rrule</code>.</p><pre><code class="language-julia hljs"># good:
function rrule(::typeof(foo), x)
    Y = foo(x)
    function foo_pullback(Ȳ)
        return NoTangent(), bar(Ȳ)
    end
    return Y, foo_pullback
end
#== output
julia&gt; rrule(foo, 2)
(4, var&quot;#foo_pullback#11&quot;())
==#

# bad:
function rrule(::typeof(foo), x)
    return foo(x), x̄ -&gt; (NoTangent(), bar(x̄))
end
#== output:
julia&gt; rrule(foo, 2)
(4, var&quot;##9#10&quot;())
==#</code></pre><p>While this is more verbose, it ensures that if an error is thrown during the <code>pullback</code> the <a href="https://docs.julialang.org/en/v1/base/base/#Base.gensym"><code>gensym</code></a> name of the local function will include the name you gave it. This makes it a lot simpler to debug from the stacktrace.</p><h2 id="Use-ZeroTangent()-as-the-return-value"><a class="docs-heading-anchor" href="#Use-ZeroTangent()-as-the-return-value">Use <code>ZeroTangent()</code> as the return value</a><a id="Use-ZeroTangent()-as-the-return-value-1"></a><a class="docs-heading-anchor-permalink" href="#Use-ZeroTangent()-as-the-return-value" title="Permalink"></a></h2><p>The <code>ZeroTangent()</code> object exists as an alternative to directly returning <code>0</code> or <code>zeros(n)</code>. It allows more optimal computation when chaining pullbacks/pushforwards, to avoid work. They should be used where possible.</p><p>However, sometimes for performance reasons this is not ideal. Especially, if it is to replace a scalar, and is in a type-unstable way. It causes problems if mapping over such pullbacks/pushforwards. This woull be solved once <a href="https://github.com/JuliaLang/julia/issues/38241">JuliaLang/julia#38241</a> has been addressed.</p><h2 id="Use-Thunks-appropriately"><a class="docs-heading-anchor" href="#Use-Thunks-appropriately">Use <code>Thunk</code>s appropriately</a><a id="Use-Thunks-appropriately-1"></a><a class="docs-heading-anchor-permalink" href="#Use-Thunks-appropriately" title="Permalink"></a></h2><p>If work is only required for one of the returned tangents, then it should be wrapped in a <code>@thunk</code> (potentially using a <code>begin</code>-<code>end</code> block).</p><p>If there are multiple return values, their computation should almost always be wrapped in a <code>@thunk</code>.</p><p>Do <em>not</em> wrap <em>variables</em> in a <code>@thunk</code>; wrap the <em>computations</em> that fill those variables in <code>@thunk</code>:</p><pre><code class="language-julia hljs"># good:
∂A = @thunk(foo(x))
return ∂A

# bad:
∂A = foo(x)
return @thunk(∂A)</code></pre><p>In the bad example <code>foo(x)</code> gets computed eagerly, and all that the thunk is doing is wrapping the already calculated result in a function that returns it.</p><p>Do not use <code>@thunk</code> if this would be equal or more work than actually evaluating the expression itself. Examples being:</p><ul><li>The expression being a constant</li><li>The expression is merely wrapping something in a <code>struct</code>, such as <code>Adjoint(x)</code> or <code>Diagonal(x)</code></li><li>The expression being itself a <code>thunk</code></li><li>The expression being from another <code>rrule</code> or <code>frule</code>; it would be <code>@thunk</code>ed if required by the defining rule already.</li><li>There is only one derivative being returned, so from the fact that the user called <code>frule</code>/<code>rrule</code> they clearly will want to use that one.</li></ul><h2 id="structs"><a class="docs-heading-anchor" href="#structs">Structs: constructors and functors</a><a id="structs-1"></a><a class="docs-heading-anchor-permalink" href="#structs" title="Permalink"></a></h2><p>To define an <code>frule</code> or <code>rrule</code> for a <em>function</em> <code>foo</code> we dispatch on the type of <code>foo</code>, which is <code>typeof(foo)</code>. For example, the <code>rrule</code> signature would be like:</p><pre><code class="language-julia hljs">function rrule(::typeof(foo), args...; kwargs...)
    ...
    return y, foo_pullback
end</code></pre><p>For a struct <code>Bar</code>,</p><pre><code class="language-julia hljs">struct Bar
    a::Float64
end

(bar::Bar)(x, y) = return bar.a + x + y # functor (i.e. callable object, overloading the call action)</code></pre><p>we can define an <code>frule</code>/<code>rrule</code> for the <code>Bar</code> constructor(s), as well as any <code>Bar</code> <a href="https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects">functors</a>.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><p>To define an <code>rrule</code> for a constructor for a  <em>type</em> <code>Bar</code> we need to be careful to dispatch only on <code>Type{Bar}</code>. For example, the <code>rrule</code> signature for a <code>Bar</code> constructor would be like:</p><pre><code class="language-julia hljs">function ChainRulesCore.rrule(::Type{Bar}, a)
    Bar_pullback(Δbar) = NoTangent(), Δbar.a
    return Bar(a), Bar_pullback
end</code></pre><p>Use <code>Type{&lt;:Bar}</code> (with the <code>&lt;:</code>) for non-concrete types, such that the <code>rrule</code> is defined for all subtypes. In particular, be careful not to use <code>typeof(Bar)</code> here. Because <code>typeof(Bar)</code> is <code>DataType</code>, using this to define an <code>rrule</code>/<code>frule</code> will define an <code>rrule</code>/<code>frule</code> for all constructors.</p><p>You can check which to use with <code>Core.Typeof</code>:</p><pre><code class="language-julia hljs">julia&gt; function foo end
foo (generic function with 0 methods)

julia&gt; typeof(foo)
typeof(foo)

julia&gt; Core.Typeof(foob)
typeof(foo)

julia&gt; typeof(Bar)
DataType

julia&gt; Core.Typeof(Bar)
Type{Bar}

julia&gt; abstract type AbstractT end

julia&gt; typeof(AbstractT)
DataType

julia&gt; Core.Typeof(AbstractT)
Type{AbstractT}</code></pre><h3 id="Functors-(callable-objects)"><a class="docs-heading-anchor" href="#Functors-(callable-objects)">Functors (callable objects)</a><a id="Functors-(callable-objects)-1"></a><a class="docs-heading-anchor-permalink" href="#Functors-(callable-objects)" title="Permalink"></a></h3><p>In contrast to defining a rule for a constructor, it is possible to define rules for calling an instance of an object. In that case, use <code>bar::Bar</code>, i.e.</p><pre><code class="language-julia hljs">function ChainRulesCore.rrule(bar::Bar, x, y)
    # Notice the first return is not `NoTangent()`
    Bar_pullback(Δy) = Tangent{Bar}(;a=Δy), Δy, Δy
    return bar(x, y), Bar_pullback
end</code></pre><p>to define the rules.</p><h2 id="Ensure-your-pullback-can-accept-the-right-types"><a class="docs-heading-anchor" href="#Ensure-your-pullback-can-accept-the-right-types">Ensure your pullback can accept the right types</a><a id="Ensure-your-pullback-can-accept-the-right-types-1"></a><a class="docs-heading-anchor-permalink" href="#Ensure-your-pullback-can-accept-the-right-types" title="Permalink"></a></h2><p>As a rule the number of types you need to accept in a pullback is theoretically unlimitted, but practically highly constrained to be in line with the primal return type. The three kinds of inputs you will practically need to accept one or more of: <em>natural tangents</em>, <em>structural tangents</em>, and <em>thunks</em>. You do not in general have to handle <code>AbstractZero</code>s as the AD system will not call the pullback if the input is a zero, since the output will also be. Some more background information on these types can be found in <a href="../design/many_tangents.html#manytypes">the design notes</a>. In many cases all these tangents can be treated the same: tangent types overload a bunch of linear-operators, and the majority of functions used inside a pullback are linear operators. If you find linear operators from Base/stdlibs that are not supported, consider opening an issue or a PR on the <a href="https://github.com/JuliaDiff/ChainRulesCore.jl/">ChainRulesCore.jl repo</a>.</p><h3 id="Natural-tangents"><a class="docs-heading-anchor" href="#Natural-tangents">Natural tangents</a><a id="Natural-tangents-1"></a><a class="docs-heading-anchor-permalink" href="#Natural-tangents" title="Permalink"></a></h3><p>Natural tangent types are the types you might feel the tangent should be, to represent a small change in the primal value. For example, if the primal is a <code>Float32</code>, the natural tangent is also a <code>Float32</code>. Slightly more complex, for a <code>ComplexF64</code> the natural tangent is again also a <code>ComplexF64</code>, we almost never want to use the structural tangent <code>Tangent{ComplexF64}(re=..., im=...)</code> which is defined. For other cases, this gets a little more complicated, see below. These are a purely human notion, they are the types the user wants to use because they make the math easy. There is currently no formal definition of what constitutes a natural tangent, but there are a few heuristics. For example, if a primal type <code>P</code> overloads subtraction (<code>-(::P,::P)</code>) then that generally returns a natural tangent type for <code>P</code>; but this is not required to be defined and sometimes it is defined poorly.</p><p>Common cases for types that represent a <a href="https://en.wikipedia.org/wiki/Vector_space">vector-space</a> (e.g. <code>Float64</code>, <code>Array{Float64}</code>) is that the natural tangent type is the same as the primal type. However, this is not always the case. For example for a <a href="https://github.com/JuliaStats/PDMats.jl"><code>PDiagMat</code></a> a natural tangent is <code>Diagonal</code> since there is no requirement that a positive definite diagonal matrix has a positive definite tangent. Another example is for a <code>DateTime</code>, any <code>Period</code> subtype, such as <code>Millisecond</code> or <code>Nanosecond</code> is a natural tangent. There are often many different natural tangent types for a given primal type. However, they are generally closely related and duck-type the same. For example, for most <code>AbstractArray</code> subtypes, most other <code>AbstractArray</code>s (of right size and element type) can be considered as natural tangent types.</p><p>Not all types have natural tangent types. For example there is no natural tangent for a <code>Tuple</code>. It is not a <code>Tuple</code> since that doesn&#39;t have any method for <code>+</code>. Similar is true for many <code>struct</code>s. For those cases there is only a structural tangent.</p><h3 id="Structural-tangents"><a class="docs-heading-anchor" href="#Structural-tangents">Structural tangents</a><a id="Structural-tangents-1"></a><a class="docs-heading-anchor-permalink" href="#Structural-tangents" title="Permalink"></a></h3><p>Structural tangents are tangent types that shadow the structure of the primal type. They are represented by the <a href="../api.html#ChainRulesCore.Tangent"><code>Tangent</code></a> type. They can represent any composite type, such as a tuple, or a structure (or a <code>NamedTuple</code>) etc.</p><div class="admonition is-info"><header class="admonition-header">Do I have to support the structural tangents as well?</header><div class="admonition-body"><p>Technically, you might not actually have to write rules to accept structural tangents; if the AD system never has to decompose down to the level of <code>getfield</code>. This is common for types that don&#39;t support user <code>getfield</code>/<code>getproperty</code> access, and that have a lot of rules for the ways they are accessed (such cases include some <code>AbstractArray</code> subtypes). You really should support it just in case; especially if the primal type in question is not restricted to a well-tested concrete type. But if it is causing struggles, then you can leave it off til someone complains.</p></div></div><h3 id="Thunks"><a class="docs-heading-anchor" href="#Thunks">Thunks</a><a id="Thunks-1"></a><a class="docs-heading-anchor-permalink" href="#Thunks" title="Permalink"></a></h3><p>A thunk (either a <a href="../api.html#ChainRulesCore.Thunk"><code>Thunk</code></a>, or a <a href="../api.html#ChainRulesCore.InplaceableThunk"><code>InplaceableThunk</code></a>), represents a delayed computation. They can be thought of as a wrapper of the value the computation returns. In this sense they wrap either a natural or structural tangent.</p><div class="admonition is-warning"><header class="admonition-header">You should support AbstractThunk inputs even if you don&#39;t use thunks</header><div class="admonition-body"><p>Unfortunately the AD sytems do not know which rules support thunks and which do not.  So all rules have to; at least if they want to play nicely with arbitrary AD systems.  Luckily it is not hard: much of the time they will duck-type as the object they wrap.  If not, then just add a <a href="../api.html#ChainRulesCore.unthunk-Tuple{Any}"><code>unthunk</code></a> after the start of your pullback.  (Even when they do duck-type, if they are used multiple times then unthunking at the start will prevent them from being recomputed.)  If you are using <a href="../api.html#ChainRulesCore.@thunk-Tuple{Any}"><code>@thunk</code></a> and the input is only needed for one of them then the <code>unthunk</code> should be in that one.  If not, and you have a bunch of pullbacks you might like to write a little helper <code>unthunking(f) = x̄ -&gt; f(unthunk(x̄))</code> that you can wrap your pullback function in before returning it from the <code>rrule</code>.  Yes, this is a bit of boiler-plate, and it is unfortunate.  Sadly, it is needed because if the AD wants to benefit it can&#39;t get that benifit unless things are not unthunked unnecessarily.  Which eventually allows them in some cases to never be unthunked at all.  There are two ways common things are never unthunked.  One is if the unthunking happens inside a <code>@thunk</code> which is never unthunked itself because it is the tangent for a primal input that never has it&#39;s tangent queried.  The second is if they are not unthunked because the rule does not need to know what is inside: consider the pullback for <code>identity</code>: <code>x̄ -&gt; (NoTangent(), x̄)</code>.</p></div></div><h2 id="Use-@not_implemented-appropriately"><a class="docs-heading-anchor" href="#Use-@not_implemented-appropriately">Use <code>@not_implemented</code> appropriately</a><a id="Use-@not_implemented-appropriately-1"></a><a class="docs-heading-anchor-permalink" href="#Use-@not_implemented-appropriately" title="Permalink"></a></h2><p>You can use <a href="../api.html#ChainRulesCore.@not_implemented-Tuple{Any}"><code>@not_implemented</code></a> to mark missing tangents. This is helpful if the function has multiple inputs or outputs, and you have worked out analytically and implemented some but not all tangents.</p><p>It is recommended to include a link to a GitHub issue about the missing tangent in the debugging information:</p><pre><code class="language-julia hljs">@not_implemented(
    &quot;&quot;&quot;
    derivatives of Bessel functions with respect to the order are not implemented:
    https://github.com/JuliaMath/SpecialFunctions.jl/issues/160
    &quot;&quot;&quot;
)</code></pre><p>Do not use <code>@not_implemented</code> if the tangent does not exist mathematically (use <code>NoTangent()</code> instead).</p><p>Note: <a href="https://github.com/JuliaDiff/ChainRulesTestUtils.jl">ChainRulesTestUtils.jl</a> marks <code>@not_implemented</code> tangents as &quot;test broken&quot;.</p><h2 id="Use-rule-definition-tools"><a class="docs-heading-anchor" href="#Use-rule-definition-tools">Use rule definition tools</a><a id="Use-rule-definition-tools-1"></a><a class="docs-heading-anchor-permalink" href="#Use-rule-definition-tools" title="Permalink"></a></h2><p>Rule definition tools can help you write more <code>frule</code>s and the <code>rrule</code>s with less lines of code. See <a href="rule_definition_tools.html#ruletools">using rule definition tools</a> section for more details.</p><h2 id="Be-careful-about-pullback-closures-calling-other-methods-of-themselves"><a class="docs-heading-anchor" href="#Be-careful-about-pullback-closures-calling-other-methods-of-themselves">Be careful about pullback closures calling other methods of themselves</a><a id="Be-careful-about-pullback-closures-calling-other-methods-of-themselves-1"></a><a class="docs-heading-anchor-permalink" href="#Be-careful-about-pullback-closures-calling-other-methods-of-themselves" title="Permalink"></a></h2><p>Due to <a href="https://github.com/JuliaLang/julia/issues/40990">JuliaLang/Julia#40990</a>, a closure calling another (or the same) method of itself often comes out uninferable (and thus effectively type-unstable). This can be avoided by moving the pullback definition outside the function, so that it is no longer a closure. For example:</p><pre><code class="language-julia hljs">double_it(x::AbstractArray) = 2 .* x

function ChainRulesCore.rrule(::typeof(double_it), x)
    double_it_pullback(ȳ::AbstractArray) = (NoTangent(), 2 .* ȳ)
    double_it_pullback(ȳ::AbstractThunk) = double_it_pullback(unthunk(ȳ))
    return double_it(x), double_it_pullback
end</code></pre><p>Ends up infering a return type of <code>Any</code></p><pre><code class="language-julia hljs">julia&gt; _, pullback = rrule(double_it, [2.0, 3.0])
([4.0, 6.0], var&quot;#double_it_pullback#8&quot;(Core.Box(var&quot;#double_it_pullback#8&quot;(#= circular reference @-2 =#))))

julia&gt; @code_warntype pullback(@thunk([10.0, 10.0]))
Variables
  #self#::var&quot;#double_it_pullback#8&quot;
  ȳ::Core.Const(Thunk(var&quot;#9#10&quot;()))
  double_it_pullback::Union{}

Body::Any
1 ─ %1 = Core.getfield(#self#, :double_it_pullback)::Core.Box
│   %2 = Core.isdefined(%1, :contents)::Bool
└──      goto #3 if not %2
2 ─      goto #4
3 ─      Core.NewvarNode(:(double_it_pullback))
└──      double_it_pullback
4 ┄ %7 = Core.getfield(%1, :contents)::Any
│   %8 = Main.unthunk(ȳ)::Vector{Float64}
│   %9 = (%7)(%8)::Any
└──      return %9</code></pre><p>This can be solved by moving the pullbacks outside the function so they are not closures, and thus to not run into this upstream issue. In this case that is fairly simple, since this example doesn&#39;t close over anything (if it did then would need a closure calling an outside function that calls itself. See <a href="https://github.com/JuliaDiff/ChainRules.jl/blob/773039a2dc0a1938f61cf26012b1223c942bc18f/src/rulesets/LinearAlgebra/structured.jl#L107-L116">this example</a>.).</p><pre><code class="language-julia hljs">_double_it_pullback(ȳ::AbstractArray) = (NoTangent(), 2 .* ȳ)
_double_it_pullback(ȳ::AbstractThunk) = _double_it_pullback(unthunk(ȳ))

function ChainRulesCore.rrule(::typeof(double_it), x)
    return double_it(x), _double_it_pullback
end</code></pre><p>This infers just fine:</p><pre><code class="language-julia hljs">julia&gt; _, pullback = rrule(double_it, [2.0, 3.0])
([4.0, 6.0], _double_it_pullback)

julia&gt; @code_warntype pullback(@thunk([10.0, 10.0]))
Variables
  #self#::Core.Const(_double_it_pullback)
  ȳ::Core.Const(Thunk(var&quot;#7#8&quot;()))

Body::Tuple{NoTangent, Vector{Float64}}
1 ─ %1 = Main.unthunk(ȳ)::Vector{Float64}
│   %2 = Main._double_it_pullback(%1)::Core.PartialStruct(Tuple{NoTangent, Vector{Float64}}, Any[Core.Const(NoTangent()), Vector{Float64}])
└──      return %2</code></pre><p>Though in this particular case, it can also be solved by taking advantage of duck-typing and just writing one method. Thus avoiding the call that confuses the compiler. <code>Thunk</code>s duck-type as the type they wrap in most cases: including broadcast multiplication.</p><pre><code class="language-julia hljs">function ChainRulesCore.rrule(::typeof(double_it), x)
    double_it_pullback(ȳ) = (NoTangent(), 2 .* ȳ)
    return double_it(x), double_it_pullback
end</code></pre><p>This infers perfectly.</p><h2 id="CAS-systems-are-your-friends."><a class="docs-heading-anchor" href="#CAS-systems-are-your-friends.">CAS systems are your friends.</a><a id="CAS-systems-are-your-friends.-1"></a><a class="docs-heading-anchor-permalink" href="#CAS-systems-are-your-friends." title="Permalink"></a></h2><p>It is very easy to check gradients or derivatives with a computer algebra system (CAS) like <a href="https://www.wolframalpha.com/input/?i=gradient+atan2%28x%2Cy%29">WolframAlpha</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="rule_definition_tools.html">« Rule definition tools</a><a class="docs-footer-nextpage" href="testing.html">Testing your rules »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Friday 16 September 2022 04:20">Friday 16 September 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

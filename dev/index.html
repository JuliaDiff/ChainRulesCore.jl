<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · ChainRules</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="ChainRules logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ChainRules</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">Introduction</a><ul class="internal"><li><a class="tocitem" href="#ChainRules-ecosystem-organisation"><span>ChainRules ecosystem organisation</span></a></li><li><a class="tocitem" href="#ChainRules-roll-out-status"><span>ChainRules roll-out status</span></a></li><li><a class="tocitem" href="#Key-functionality"><span>Key functionality</span></a></li><li><a class="tocitem" href="#Example-of-using-ChainRules-directly"><span>Example of using ChainRules directly</span></a></li></ul></li><li><span class="tocitem">How to use ChainRules as a rule author</span><ul><li><a class="tocitem" href="rule_author/intro.html">Introduction</a></li><li><a class="tocitem" href="rule_author/example.html">Pedagogical example</a></li><li><a class="tocitem" href="rule_author/tangents.html">Tangent types</a></li><li><a class="tocitem" href="rule_author/which_functions_need_rules.html">Which functions need rules?</a></li><li><a class="tocitem" href="rule_author/rule_definition_tools.html">Rule definition tools</a></li><li><a class="tocitem" href="rule_author/writing_good_rules.html">Writing good rules</a></li><li><a class="tocitem" href="rule_author/testing.html">Testing your rules</a></li><li><input class="collapse-toggle" id="menuitem-2-8" type="checkbox"/><label class="tocitem" for="menuitem-2-8"><span class="docs-label">Superpowers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="rule_author/superpowers/projectto.html"><code>ProjectTo</code></a></li><li><a class="tocitem" href="rule_author/superpowers/opt_out.html"><code>@opt_out</code></a></li><li><a class="tocitem" href="rule_author/superpowers/ruleconfig.html"><code>RuleConfig</code></a></li><li><a class="tocitem" href="rule_author/superpowers/gradient_accumulation.html">Gradient accumulation</a></li></ul></li><li><a class="tocitem" href="rule_author/converting_zygoterules.html">Converting ZygoteRules.@adjoint to rrules</a></li><li><a class="tocitem" href="rule_author/tips_for_packages.html">Tips for making your package work with AD</a></li><li><a class="tocitem" href="rule_author/debug_mode.html">Debug mode</a></li></ul></li><li><span class="tocitem">How to support ChainRules rules as an AD package author</span><ul><li><a class="tocitem" href="ad_author/use_in_ad_system.html">Usage in AD</a></li><li><a class="tocitem" href="ad_author/call_back_into_ad.html">Support calling back into ADs</a></li><li><a class="tocitem" href="ad_author/opt_out.html">Support opting out of rules</a></li></ul></li><li><span class="tocitem">The maths</span><ul><li><a class="tocitem" href="maths/propagators.html">The propagators: pushforward and pullback</a></li><li><a class="tocitem" href="maths/nondiff_points.html">Non-differentiable Points</a></li><li><a class="tocitem" href="maths/complex.html">Complex numbers</a></li><li><a class="tocitem" href="maths/arrays.html">Deriving array rules</a></li></ul></li><li><span class="tocitem">Design</span><ul><li><a class="tocitem" href="design/changing_the_primal.html">Changing the Primal</a></li><li><a class="tocitem" href="design/many_tangents.html">Many Tangent Types</a></li></ul></li><li><a class="tocitem" href="videos.html">Videos</a></li><li><a class="tocitem" href="FAQ.html">FAQ</a></li><li><a class="tocitem" href="api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ChainRules"><a class="docs-heading-anchor" href="#ChainRules">ChainRules</a><a id="ChainRules-1"></a><a class="docs-heading-anchor-permalink" href="#ChainRules" title="Permalink"></a></h1><p><a href="https://en.wikipedia.org/wiki/Automatic_differentiation">Automatic differentiation (AD)</a> is a set of techniques for obtaining derivatives of arbitrary functions. There are surprisingly many packages for doing AD in Julia. ChainRules isn&#39;t one of these packages.</p><p>The AD packages essentially combine derivatives of simple functions into derivatives of more complicated functions. They differ in the way they break down complicated functions into simple ones, but they all require a common set of derivatives of simple functions (rules).</p><p><a href="https://github.com/JuliaDiff/ChainRules.jl">ChainRules</a> is an AD-independent set of rules, and a system for defining and testing rules.</p><div class="admonition is-info"><header class="admonition-header">What is a rule?</header><div class="admonition-body"><p>A rule encodes knowledge about propagating derivatives, e.g. that the derivative with respect to <code>x</code> of <code>a*x</code> is <code>a</code>, and the derivative of <code>sin(x)</code> is <code>cos(x)</code>, etc.</p></div></div><h2 id="ChainRules-ecosystem-organisation"><a class="docs-heading-anchor" href="#ChainRules-ecosystem-organisation">ChainRules ecosystem organisation</a><a id="ChainRules-ecosystem-organisation-1"></a><a class="docs-heading-anchor-permalink" href="#ChainRules-ecosystem-organisation" title="Permalink"></a></h2><p>The ChainRules ecosystem comprises:</p><ul><li><a href="https://github.com/JuliaDiff/ChainRulesCore.jl">ChainRulesCore.jl</a>: a system for defining rules, and a collection of tangent types.</li><li><a href="https://github.com/JuliaDiff/ChainRules.jl">ChainRules.jl</a>: a collection of rules for Julia Base and standard libraries.</li><li><a href="https://github.com/JuliaDiff/ChainRulesTestUtils.jl">ChainRulesTestUtils.jl</a>: utilities for testing rules using finite differences.</li></ul><p>AD systems depend on ChainRulesCore.jl to get access to tangent types and the core rule definition functionality (<code>frule</code> and <code>rrule</code>), and on ChainRules.jl to benefit from the collection of rules for Julia Base and the standard libraries.</p><p>Packages that just want to define rules only need to depend on <a href="https://github.com/JuliaDiff/ChainRulesCore.jl">ChainRulesCore.jl</a>, which is an exceptionally light dependency. They should also have a test-only dependency on <a href="https://github.com/JuliaDiff/ChainRulesTestUtils.jl">ChainRulesTestUtils.jl</a> to test the rules using finite differences.</p><p>Note that the packages with rules do not have to depend on AD systems, and neither do the AD systems have to depend on individual packages.</p><h2 id="ChainRules-roll-out-status"><a class="docs-heading-anchor" href="#ChainRules-roll-out-status">ChainRules roll-out status</a><a id="ChainRules-roll-out-status-1"></a><a class="docs-heading-anchor-permalink" href="#ChainRules-roll-out-status" title="Permalink"></a></h2><p>Numerous <a href="https://juliahub.com/ui/Packages/ChainRulesCore/G6ax7/?page=2">packages</a> depend on ChainRulesCore to define rules for their functions.</p><p>6 AD engines currently use ChainRules to get access to rules:</p><p><a href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a> is a reverse-mode AD that supports using <code>rrule</code>s, calling back into AD, and opting out of rules. However, its own <a href="https://github.com/FluxML/ZygoteRules.jl/">ZygoteRules.jl</a> primitives (<code>@adjoint</code>s) take precedence before <code>rrule</code>s when both are defined – even if the <code>@adjoint</code> is less specific than the <code>rrule</code>. Internally it uses its own set of tangent types, e.g. <code>nothing</code> instead of <code>NoTangent</code>/<code>ZeroTangent</code>. It also <code>unthunk</code>s every tangent.</p><p><a href="https://github.com/JuliaDiff/Diffractor.jl">Diffractor.jl</a> is a forward- and reverse-mode AD that fully supports ChainRules, including calling back into AD, opting out of rules, and uses tangent types internally.</p><p><a href="https://github.com/dfdx/Yota.jl">Yota</a> is a reverse-mode AD that fully supports ChainRules, including calling back into AD, opting out of rules, and uses tangent types internally.</p><p><a href="https://github.com/JuliaDiff/ReverseDiff.jl">ReverseDiff</a> is a reverse-mode AD that supports using <code>rrule</code>s, but not calling back into AD and opting out of rules.</p><p><a href="https://github.com/invenia/Nabla.jl">Nabla.jl</a> is a reverse-mode AD that supports using <code>rrule</code>s, but not opting out of rules, nor calling back into AD.</p><p><a href="https://github.com/dpsanders/ReversePropagation.jl">ReversePropagation.jl</a> is a reverse-mode AD that supports using <code>rrule</code>s for scalar functions, but not calling back into AD and opting out of rules.</p><p>On the other hand, <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> is NOT natively compatible with ChainRules. You can use the package <a href="https://github.com/ThummeTo/ForwardDiffChainRules.jl">ForwardDiffChainRules.jl</a> to bridge this gap.</p><h2 id="Key-functionality"><a class="docs-heading-anchor" href="#Key-functionality">Key functionality</a><a id="Key-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Key-functionality" title="Permalink"></a></h2><p>Consider a relationship <span>$y = f(x)$</span>, where <span>$f$</span> is some function. Computing <span>$y$</span> from <span>$x$</span> is the original problem, called the <em>primal</em> computation, in contrast to the problem of computing derivatives. We say that the <em>primal function</em> <span>$f$</span> takes a <em>primal input</em> <span>$x$</span> and returns the <em>primal output</em> <span>$y$</span>.</p><p>ChainRules rules are concerned with propagating <em>tangents</em> of primal inputs to <em>tangents</em> of primal outputs (<code>frule</code>, from forwards mode AD), and propagating <em>cotangents</em> of primal outputs to <em>cotangents</em> of primal inputs (<code>rrule</code>, from reverse mode AD). To be able to do that, ChainRules also defines a small number of tangent types to represent tangents and cotangents.</p><div class="admonition is-info"><header class="admonition-header">Tangents and cotangents</header><div class="admonition-body"><p>Strictly speaking tangents, <span>$ẋ = \frac{dx}{da}$</span>, are propagated in <code>frule</code>s, and cotangents, <span>$x̄ = \frac{da}{dx}$</span>, are propagated in <code>rrule</code>s. However, in practice there is rarely a need to distinguish between the two: both are represented by the same tangent types. Thus, except when the detail might clarify, we refer to both as tangents.</p></div></div><div class="admonition is-category-terminology"><header class="admonition-header">`frule` and `rrule`</header><div class="admonition-body"><p><code>frule</code> and <code>rrule</code> are ChainRules specific terms. Their exact functioning is fairly ChainRules specific, though other tools have similar functions. The core notion is sometimes called <em>custom AD primitives</em>, <em>custom adjoints</em>, <em>custom gradients</em>, <em>custom sensitivities</em>. The whole field is a mess for terminology.</p></div></div><h3 id="Forward-mode-AD-rules-(frules)"><a class="docs-heading-anchor" href="#Forward-mode-AD-rules-(frules)">Forward-mode AD rules (<code>frule</code>s)</a><a id="Forward-mode-AD-rules-(frules)-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-mode-AD-rules-(frules)" title="Permalink"></a></h3><p>If we know the value of <span>$ẋ = \frac{dx}{da}$</span> for some <span>$a$</span> and we want to know <span>$ẏ = \frac{dy}{da}$</span>, the <a href="https://en.wikipedia.org/wiki/Chain_rule">chain rule</a> tells us that <span>$ẏ = \frac{dy}{dx} ẋ$</span>. Intuitively, we are pushing the derivative forward. This is the basis for forward-mode AD.</p><div class="admonition is-info"><header class="admonition-header">frule</header><div class="admonition-body"><p>The <code>frule</code> for <span>$f$</span> encodes how to propagate the tangent of the primal input (<span>$ẋ$</span>) to the tangent of the primal output (<span>$ẏ$</span>).</p></div></div><p>The <code>frule</code> signature for a function <code>foo(args...; kwargs...)</code> is</p><pre><code class="language-julia hljs">function frule((Δself, Δargs...), ::typeof(foo), args...; kwargs...)
    ...
    return y, ∂Y
end</code></pre><p>where <code>y = foo(args; kwargs...)</code> is the primal output, and <code>∂Y</code> is the result of propagating the input tangents <code>Δself</code>, <code>Δargs...</code> forwards at the point in the domain of <code>foo</code> described by <code>args</code>. This propagation is called the pushforward. Often we will think of the <code>frule</code> as having the primal computation <code>y = foo(args...; kwargs...)</code>, and the pushforward <code>∂Y = pushforward(Δself, Δargs...)</code>, even though they are not present in separate forms in the code.</p><p>For example, the <code>frule</code> for <code>sin(x)</code> is:</p><pre><code class="language-julia hljs">function frule((_, Δx), ::typeof(sin), x)
    return sin(x), cos(x) * Δx
end</code></pre><h3 id="Reverse-mode-AD-rules-(rrules)"><a class="docs-heading-anchor" href="#Reverse-mode-AD-rules-(rrules)">Reverse-mode AD rules (<code>rrule</code>s)</a><a id="Reverse-mode-AD-rules-(rrules)-1"></a><a class="docs-heading-anchor-permalink" href="#Reverse-mode-AD-rules-(rrules)" title="Permalink"></a></h3><p>If we know the value of <span>$ȳ = \frac{da}{dy}$</span> for some <span>$a$</span> and we want to know <span>$x̄ = \frac{da}{dx}$</span>, the <a href="https://en.wikipedia.org/wiki/Chain_rule">chain rule</a> tells us that <span>$x̄ =ȳ \frac{dy}{dx}$</span>. Intuitively, we are pushing the derivative backward. This is the basis for reverse-mode AD.</p><div class="admonition is-info"><header class="admonition-header">rrule</header><div class="admonition-body"><p>The <code>rrule</code> for <span>$f$</span> encodes how to propagate the cotangents of the primal output (<span>$ȳ$</span>) to the cotangent of the primal input (<span>$x̄$</span>).</p></div></div><p>The <code>rrule</code> signature for a function <code>foo(args...; kwargs...)</code> is</p><pre><code class="language-julia hljs">function rrule(::typeof(foo), args...; kwargs...)
    ...
    return y, pullback
end</code></pre><p>where <code>y</code> (the primal output) must be equal to <code>foo(args...; kwargs...)</code>. <code>pullback</code> is a function to propagate the derivative information backwards at the point in the domain of <code>foo</code> described by <code>args</code>. That pullback function is used like: <code>∂self, ∂args... = pullback(Δy)</code> Almost always the <em>pullback</em> will be declared locally within the <code>rrule</code>, and will be a <em>closure</em> over some of the other arguments, and potentially over the primal result too.</p><p>For example, the <code>rrule</code> for <code>sin(x)</code> is:</p><pre><code class="language-julia hljs">function rrule(::typeof(sin), x)
    sin_pullback(Δy) = (NoTangent(), cos(x)&#39; * Δy)
    return sin(x), sin_pullback
end</code></pre><div class="admonition is-info"><header class="admonition-header">Why `rrule` returns a pullback but `frule` doesn&#39;t return a pushforward</header><div class="admonition-body"><p>While <code>rrule</code> takes only the arguments to the original function (the primal arguments) and returns a function (the pullback) that operates with the derivative information, the <code>frule</code> does it all at once. This is because the <code>frule</code> fuses the primal computation and the pushforward. This is an optimization that allows <code>frule</code>s to contain single large operations that perform both the primal computation and the pushforward at the same time (for example solving an ODE). This operation is only possible in forward mode (where <code>frule</code> is used) because the derivative information needed by the pushforward available with the <code>frule</code> is invoked – it is about the primal function&#39;s inputs. In contrast, in reverse mode the derivative information needed by the pullback is about the primal function&#39;s output. Thus the reverse mode returns the pullback function which the caller (usually an AD system) keeps hold of until derivative information about the output is available.</p></div></div><h3 id="Tangent-types"><a class="docs-heading-anchor" href="#Tangent-types">Tangent types</a><a id="Tangent-types-1"></a><a class="docs-heading-anchor-permalink" href="#Tangent-types" title="Permalink"></a></h3><p>The types of (co)-tangents depend on the types of the primals. Scalar primals are represented by scalar tangents (e.g. <code>Float64</code> tangent for a <code>Float64</code> primal). Vector, matrix, and higher rank tensor primals can be represented by vector, matrix and tensor tangents.</p><p>ChainRules defines a <a href="api.html#ChainRulesCore.Tangent"><code>Tangent</code></a> tangent type to represent tangents of <code>struct</code>s, <code>Tuple</code>s, <code>NamedTuple</code>s, and <code>Dict</code>s.</p><p>Additionally, for signalling semantics, we distinguish between two tangent types representing a zero tangent. <a href="api.html#ChainRulesCore.NoTangent"><code>NoTangent</code></a> type represent situations in which the tangent space does not exist, e.g. an index into an array can not be perturbed. <a href="api.html#ChainRulesCore.ZeroTangent"><code>ZeroTangent</code></a> is used for cases where the tangent happens to be zero, e.g. because the primal argument is not used in the computation.</p><p>We also define <a href="api.html#ChainRulesCore.Thunk"><code>Thunk</code></a>s to allow certain optimisation. <code>Thunk</code>s are a wrapper over a computation that can potentially be avoided, depending on the downstream use.</p><p>See the section on <a href="rule_author/tangents.html#tangents">tangent types</a> for more details.</p><h2 id="Example-of-using-ChainRules-directly"><a class="docs-heading-anchor" href="#Example-of-using-ChainRules-directly">Example of using ChainRules directly</a><a id="Example-of-using-ChainRules-directly-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-using-ChainRules-directly" title="Permalink"></a></h2><p>While ChainRules is largely intended as a backend for autodiff systems, it can be used directly. In fact, this can be very useful if you can constrain the code you need to differentiate to only use things that have rules defined for. This was once how all neural network code worked.</p><p>Using ChainRules directly also helps get a feel for it.</p><pre><code class="language-julia hljs">using ChainRulesCore

function foo(x)
    a = sin(x)
    b = 0.2 + a
    c = asin(b)
    return c
end

# Define rules (alternatively get them for free via `using ChainRules`)
@scalar_rule(sin(x), cos(x))
@scalar_rule(+(x, y), (1.0, 1.0))
@scalar_rule(asin(x), inv(sqrt(1 - x^2)))</code></pre><pre><code class="language-julia hljs">#### Find dfoo/dx via rrules
#### First the forward pass, gathering up the pullbacks
x = 3;
a, a_pullback = rrule(sin, x);
b, b_pullback = rrule(+, 0.2, a);
c, c_pullback = rrule(asin, b)

#### Then the backward pass calculating gradients
c̄ = 1;                    # ∂c/∂c
_, b̄ = c_pullback(c̄);     # ∂c/∂b = ∂c/∂b ⋅ ∂c/∂c
_, _, ā = b_pullback(b̄);  # ∂c/∂a = ∂c/∂b ⋅ ∂b/∂a
_, x̄ = a_pullback(ā);     # ∂c/∂x = ∂c/∂a ⋅ ∂a/∂x
x̄                         # ∂c/∂x = ∂foo/∂x
# output
-1.0531613736418153</code></pre><pre><code class="language-julia hljs">#### Find dfoo/dx via frules
x = 3;
ẋ = 1;              # ∂x/∂x
nofields = ZeroTangent();  # ∂self/∂self

a, ȧ = frule((nofields, ẋ), sin, x);                    # ∂a/∂x = ∂a/∂x ⋅ ∂x/∂x 
b, ḃ = frule((nofields, ZeroTangent(), ȧ), +, 0.2, a);  # ∂b/∂x = ∂b/∂a ⋅ ∂a/∂x
c, ċ = frule((nofields, ḃ), asin, b);                   # ∂c/∂x = ∂c/∂b ⋅ ∂b/∂x
ċ                                                       # ∂c/∂x = ∂foo/∂x
# output
-1.0531613736418153</code></pre><pre><code class="language-julia hljs">#### Find dfoo/dx via FiniteDifferences.jl
using FiniteDifferences
central_fdm(5, 1)(foo, x)
# output
-1.0531613736418257

#### Find dfoo/dx via ForwardDiff.jl
using ForwardDiff
ForwardDiff.derivative(foo, x)
# output
-1.0531613736418153

#### Find dfoo/dx via Zygote.jl
using Zygote
Zygote.gradient(foo, x)
# output
(-1.0531613736418153,)</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="rule_author/intro.html">Introduction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Tuesday 17 October 2023 09:00">Tuesday 17 October 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
